# Տեքստից ենթատեքստի ստացումը: Ի՞նչ մեթոդներ կան, ո՞րն է այդ մեթոդներից ամենաճկունը

Շատ հաճախ մեզ պետք է լինում ոչ միայն պարզել արդյո՞ք տեքստը պարունակում է այդ ենթատողը և որ ինդեքսում է այն գտնվում, այլ նաև ստանալ այն և օգտագործել։ **_JavaScript_**-ը դրա համար ունի 3 ներդրված մեթոդ։ Փորձենք մանրամասն քննարկել այդ մեթոդները, և պարզել որն է նրանցից ամենաճկունը։ Եվ այսպես այդ մեթոդներն են՝

- substring
- substr
- slice

Սկսենք **substring** -ից։ Նախ տեսնենք թե **_MDN_**-ում ոնց է նկարագրվում տվյալ մեթոդը և ինչպես է այն աշխատում։ Գրելաձևը հետևյալն է՝

**str.substring(start [,end]),** որտեղ․

- _start_-ն ամբողջ թիվ է, որը կարող է լինել 0-ից մինչև տեքստի երկարության չափ։ Այն _ԸՆԴԳՐԿՎՈՒՄ Է_ արդյունքում ստացվելիք ենթատեքստի մեջ։
- _end_-ը ոչ պարտադիր (օպցիոնալ) երկրորդ պարամետրն է։ Սա նույնպես ամբողջ թիվ է, որի տիրույթը կարող է լինել 0-ից մինչև տեքստի երկարության չափ։ Արդյունքում ստացվելիք ենթատեքստի մեջ _end_-ին համապատասխանող ինդեքսում գտնվող սիմվոլը _ՉԻ ԸՆԴԳՐԿՎՈՒՄ_։ Այսպիսով ՝

- Եթե _start_ արգումենտը հավասար է _end_ արգումենտին, ապա **substring** մեթոդը կվերադարձնի դատարկ տող։
- Եթե _end_ արգումենտը բացակայում է, ապա **substring** մեթոդը կառանձնացնի _start_-ից սկսած մինչև տեքստի վերջն ընկած ենթատեքստը։

- Եթե արգումենտներից յուրաքանչյուրը փոքր է 0-ից, կամ հավասար է _NaN_-ի, ապա այն կընկալվի որպես հավասար 0-ի։
- Եթե արգումենտներից յուրաքանչյուրը մեծ է տողի երկարության չափից, ապա այն կընկալվի որպես մաքսիմալ հնարավոր արժեքով՝ այսինքն տեքստի երկարության չափ։
- Եթե _start_ արգումենտը մեծ լինի _end_ արգումենտից, ապա մեթոդը կաշխատի այնպես, ասես թե արգումենտները տեղերով փոխված են։ Օրինակ՝ _str.substring(1, 0) === str.substring(0, 1)_։

Այժմ դիտարկենք մի քանի օրինակներ․

```
let str = "Armenian JavaScript Community"
console.log(str.substring( 0, 3 )); // "Arm"
console.log(str.substring( 3, 0 )); // "Arm"
```

Վերևի օրինակի երկու դեպքում էլ կստանանք "Arm" ենթատեքստը։

```
console.log(str.substring( 9, 19 )); // "JavaScript"
console.log(str.substring( 19, 9 )); // "JavaScript"
```

Այս երկու դեպքն էլ կվերադարձնի "JavaScript" ենթատեքստը։

Հաջորդը՝ **substr** մեթոդն է։ Կրկին դիմենք **_MDN_**-ի օգնությանը պարզելու համար թե ինչպես է այն աշխատում։ Գրելաձևը հետևյալն է՝

**_str.substr(start [,length])_**, որտեղ․

- _start_ - Դիրքն է, որտեղից սկսած «առանձնացնելու» է սիմվոլները։ Բնականաբար պետք է լինի ամբողջ թիվ։ Եթե տրված է բացասական թիվ, ապա այն ընկալվում է որպես _(str.length - start)_, որտեղ _str.length_-ը տեքստի երկարությունն է։

- _length_ - Ոչ պարտադիր երկրորդ պարամետրն է։ Այն ցույց է տալիս թե քանի սիմվոլ ենք մենք ուզում ստանալ։ Մեթոդը վերադարձնում է նոր տեքստ՝ բաղկացած հին տեքստի այն մասից, որը մենք «կտրել» ենք տրված արգումենտների օգնությամբ։

Այսպիսով՝

- Եթե _start_ արգումենտը դրական թիվ է, և այն մեծ կամ հավասար է տեքստի երկարությանը, ապա մեթոդը վերադարձնում է դատարկ տող։
- Եթե _start_ արգումենտը լինի բացասական թիվ, ապա **substr** մեթոդը կօգտագործի նրան, հաշվարկը կատարելով տեքստի վերջից։ Եթե բացի նրանից որ բացասական լինի, նաև մոդուլով մեծ լինի տեքստի երկարությունից, ապա կընկալվի որպես 0։

_start_ արգումենտի բացասական լինելը նորմալ է **_JavaScript_**-ի, բայց ոչ **ECMAScript-262**-ի մյուս հայտնի ռեալիզացիա **JScript** _(JavaScripti-ի Microsofti-ի տարբերակը)_ - ի մոտ։

- Եթե _length_ արգումենտը 0 կամ բացասական թիվ է, ապա մեթոդը կվերադարձնի դատարկ տող։ Եթե այն բացակայում է, ապա մեթոդը կվերադարձնի սկսած _start_-ից մինչև տողի վերջ եղած ենթատողը։

Ահա մի քանի օրինակներ ՝

```
const str = "Armenian JavaScript Community";
console.log(str.substr(9, 20)); // "JavaScript Community"
console.log(str.substr(-9, 10)); // "Community"
```

Եվ իհարկե վերջին և ամենակարևոր մեթոդը՝ **slice**-ը։ Գրելաձևը հետևյալն է՝

**str.slice(start [,end])**;

Որտեղ՝

- start - Ինդեքսն է, որտեղից պետք է սկսել հաշվարկը։ Եթե այն բացասական է, ապա կընկալվի որպես _str.length + start_, որտեղ _str.length_-ը դա տեքստի երկարությունն է։

- end - Ոչ պարտադիր երկրորդ պարամետրն է։ Այս պարամետրով տալիս ենք թե մինչև որտեղ ենք ուզում մեթոդի օգնությամբ ենթատեքստը առանձնացնել։ Եթե այն բաց թողենք, ապա մեթոդը կառանձնացնի _start_-ից սկսած մինչև տեքստի վերջ։ Եթե այն բացասական թիվ է, ապա ընկալվում է որպես _str.length + end_, որտեղ _str.length_-ը տողի երկարությունն է։

**slice** մեթոդը վերադարձնում է ենթատեքստը, որը սկսվում է տողի _start_ ինդեքսին պատկանող սիմվոլից և վերջանում է
_end_ ինդեքսի մոտ (_end ինդեքսին պատկանող սիմվոլը ՉԻ ԸՆԴԳՐԿՎՈՒՄ վերադարձվող ենթատողի մեջ_)։ Բերենք մի քանի օրինակներ՝

```
let str = "Armenian JavaScript Community";
console.log(str.slice( 0, 8)) // "Armenian"
console.log(str.slice( 8, 19)) // "JavaScript"
console.log(str.slice( 9, -10)) // "JavaScript"
```

Կարևոր է հիշել, որ _String_ տիպը **_JavaScript_**-ում ՉԻ ԿԱՐՈՂ ՓՈՓՈԽՄԱՆ ԵՆԹԱՐԿՎԵԼ։ Այն ինչպես ստեղծեցինք, այնպես էլ ընդմիշտ կմնա։ Բոլոր այս 3 մեթոդները ՎԵՐԱԴԱՐՁՆՈՒՄ ԵՆ ՆՈՐ _String_, և ՓՈՓՈԽՈՒԹՅԱՆ ՉեՆ ԵՆԹԱՐԿՈՒՄ ՀԻՆԸ։ Հավանաբար կարող է հարց առաջանալ, թե այս մեթոդներից որն օգտագործել, որն է այն մեթոդը, որն ունիվերսալ է և ճկուն, համեմատած մնացած մեթոդների հետ։

Իհարկե **_slice-ը_**։ Թեև _substr_-ը նույնպես հրաշալի մեթոդ է, և որոշ դեպքերում կարող է հարմար լինել, այն ունի մեկ թերություն՝ նկարագրված չէ **ECMAScript** ստանդարտում և ստեղծվել է բրաուզերային միջավայրում կիրառելու համար։ Այսինքն կա հավանականություն, որ ոչ բրաուզերային միջավայրում այն կարող է չաջակցվել։ **_slice_**- ն ավելի կարճ է, ճկուն, և բոլոր միջավայրերում հրաշալի աշխատում է։ Այնպես որ կարիք չկա հիշելու մյուս երկուսի աշխատանքի սկզբունքները, իսկ եթե կարիք առաջանա էլ, հավանաբար գիտեք թե որտեղ նայել: Մեթոդներին ավելի մանրամասն կարելի է ծանոթանալ այս հղումներով՝

- [`substring`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/substring)
- [`substr`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/substr)
- [`slice`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)
