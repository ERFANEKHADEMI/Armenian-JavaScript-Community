# Խնդիր համար 2 - Գտնել ձայնավորների քանակը բառի մեջ։

Բավականին տարածված ու հեշտ խնդիր է, հաճախակի հանդիպում է հարցազրույցների ժամանակ։ Պետք է գրել այնպիսի ֆունկցիա, որը որպես արգումենտ կստանա տեքստ, և կվերադարձնի տվյալ տեքստի մեջ եղած ձայնավորների քանակը։ Անգլերենի այբուբենում ձայնավորներ են հանդիսանում հետևյալ հնչյունները՝ _«a», «e», «i», «o», «u»_։ Օրինակ՝

```
findVowels("independent") // 4
findVowels("fine") // 2
findVowels("dry") // 0
```

Ֆունկցիան կարելի է գրել հետևյալ կերպ՝

```
function findVowels(str) {
  let count = 0;
  const vowels = [ "a", "e", "i", "o", "u" ];

  for(let char of str.toLowerCase()) {
    if(vowels.includes(char)) {
      count++
    }
  }
  return count
}
```

Փորձենք հասկանալ թե ինչպես է այն աշխատում։ Նախ և առաջ ֆունկցիայի մարմնում հայտարարում ենք _counter_ փոփոխականը։ Նրա դերը կայանալու է ձայնավորների քանակը պահելու մեջ։ Այն, կարող ենք ասել, որ հանդիսանում է «հաշվիչ», և որպես սկզբնական արժեք մենք նրան վերագրում ենք _0_։ Հաջորդ տողում հայտարարում ենք _vowels_ կոնստանտը _(հաստատունը)_, որին վերագրում ենք զանգված, որն իր մեջ պարունակում է բոլոր ձայնավորները։

Հաջորդը _for of_ ցիկլն է, այն լեզվին ավելացել է **_ES6_** ստանդարտից սկսած, և թույլ է տալիս աշխատել բոլոր _iterable_ օբյեկտների հետ։ Քանի-որ տողերը նույնպես _iterable_ են, նրանց հետ շատ հարմար ձևով կարող ենք աշխատել _for of_ ցիկլի օգնությամբ։ Ցիկլը անցնում է տողի յուրաքանչյուր տառի վրայով, _toLowerCase()_ ներդրված մեթոդի միջոցով տառերը բերում է մի տեսքի՝ բոլորին վերածում է փոքրատառի, հետո ձայնավորների _vowels_ զանգվածի վրա կանչվում է _includes()_ մեթոդը, որը վերադարձնում է բուլյան արժեք, այսինքն _true_, եթե տառը գտել է զանգվածի մեջ և _false_, եթե չի գտել այն։ Ամեն անգամ երբ _vowels.includes(char)_ - ը ստանում է _true_ արժեք, _counter_ անվանված փոփոխականի արժեքը _1_-ով ավելանում է։ Եվ ամենավերջում, ֆունկցիան վերադարձնում է հենց այդ _counter_ փոփոխականը։

Խնդիրը շատ ավելի գեղեցիկ ու կարճ կարելի է լուծել _regular expression_-ի օգնությամբ։

```
function findVowels(str) {
  const matched = str.match(/[aeiou]/gi)
  return matched ? matched.length : 0
 }
```

Այստեղ մենք օգտագործում ենք ներդրված _match_ մեթոդը, որը կանչվում է տողի վրա, և որպես պարամետր ստանում է _regular expression_։ _/[aeiou]/_ արտահայտությունը նշանակում է, որ մենք տողի մեջ ման ենք գալիս քառակուսի փակագծերի մեջ նշված տառերը։ Դրանից հետո գրված _g (global)_ տառը ինտերպրետատորին հասկացնում է, որ որոնումը պետք է անել մինչև վերջ, ոչ թե առաջին համընկնումը գտնելու դեպքում այն դադարեցնել։ _g_-ից հետո գրված _i_ տառը նշանակում է, որ որոնման ժամանակ չպետք է հաշվի առնվի տառի մեծատառ կամ փոքրատառ լինելը։ Օրինակ _/a/i_-ն նշանակում է, որ մեզ պետք է ինչպես _a_-ն, այնպես էլ _A_-ն։ Եվ այսպիսով _match_ մեթոդը ավարտելով որոնումը, վերադարձնում է զանգված, որը պարունակում է բոլոր համընկած տառերը _(կոնկրետ մեր օրինակում՝ ձայնավորները)_։ Համընկնում չլինելու դեպքում այն վերադարձնում է _null_: Մեզ մնում է ընդամենը պարզել զանգվածի մեջ գտնվող տառերի քանակը, ինչը շատ հեշտ կարող ենք անել զանգվածի _length_ մեթոդի օգնությամբ։

Այսպիսով վերջին տողում թերնար _(?)_ օպերատորի օգնությամբ, մենք ասում ենք, եթե համընկնում կա, այսինքն _match_ մեթոդը վերադարձրել է զանգված, ապա թող ֆունկցիան վերադարձնի այդ զանգվածի էլեմենտների քանակը, կոնկրետ մեր օրինակի դեպքում՝ ձայնավորների։ Եթե համընկնում չկա, այսինքն _match_ մեթոդը վերադարձրել է _null_, ապա թող ֆունկցիան վերադարձնի _0_։
