# Ստեղծենք ՖՈՒՆԿՑԻԱ, որը շատ ավելի ճշգրիտ է աշխատում և անհամեմատ օգտակար է, քան typeof օպերատորը

**_typeof_** օպերատորի միջոցով տվյալների տիպը որոշելու ժամանակ բոլոր օբյեկտային _(հղումային)_ տիպերի համար վերադարձվում է **"object"**, լինի դա սովորական _օբյեկտ_, _զանգված_, _Map_ թե _Set_. Մեր ստեղծած Ֆունկցիան պետք է ճշգրիտ ցույց տա թե օբյեկտային տիպի կոնկրետ ո՞ր դասին են պատկանում տվյալները և կարողանա տարբերել օրինակ _զանգվածը_՝ _Map_-ից

Ինչպես գիտենք **_ECMAScript 2023_** կամ համառոտ՝ **_ES14_** ստանդարտով JavaScript-ում կան _7_ պրիմիտիվ և _մեկ_ օբյեկտային _(reference type)_ տվյալների տեսակներ։(Իրականում ամեն ինչ մի փոքր այլ է, և JS-ում չկան պրիմիտիվ տիպեր այն իմաստով, ինչ մի շարք այլ ծրագրավորման լեզուներում է, և մի շարք այսպես կոչված «պրիմիտիվ» տիպեր JS-ում հանդիսանում են ուղղակի անփոփոխելի օբյեկտներ, բայց դա արդեն այլ ծավալուն թեմա է)։ Օբյեկտային տիպը իր հերթին բաժանվում է մի քանի դասերի։ Օրինակ թե՛ _Array_-ը, թե՛ _Function_-ը, թե՛ _Map_-ն ու _Set_-ը համարվում են օբյեկտներ։ Երբ մենք տվյալների տիպը որոշելու համար օգտագործում ենք **_typeof_** օպերատորը, այն երբեմն իրոք հարմար չէ, որովհետև նա մեզ ինֆորմացիա չի տալիս, թե կոնկրետ ինչ դասի օբյեկտ է ստուգվողը։ Բացի դրանից **_typeof_** օպերատորը _Null_ տիպը ստուգելուց վերադարձնում է _"object"_, ինչը նույնպես կարող է թյուրիմացությունների պատճառ դառնալ։

Այժմ փորձենք ստեղծել ֆունկցիա, որը չի ունենա **_typeof_** օպերատորի թերությունները, և օգտակար կլինի լայն սպեկտրով խնդիրների լուծման համար։

Տարբեր արժեքների վրա Օբյեկտի նախատիպի _(Object.prototype) toString()_ մեթոդի կանչը վերադարձնում է տարբեր արդյունքներ։ Օրինակ՝

```
Object.prototype.toString.call("hello") // "[object String]"
Object.prototype.toString.call(888) // "[object Number]"
Object.prototype.toString.call({}) // "[object Object]"
Object.prototype.toString.call(/abc/) // "[object RegExp]"
Object.prototype.toString.call(new Date()) // "[object Date]"
```

Այսպիսով ինչպես տեսնում ենք մեթոդը միշտ վերադարձնում է սթրինգ, որի առաջին բառը դա _object_-ն է, իսկ երկրորդը թե այն ինչ դասի է պատկանում։ Փաստորեն եթե մենք օգտագործենք _regular expression_ կամ սթրինգի _slice()_ մեթոդը, կարող ենք կտրել վերադարձվող արժեքի մեզ ոչ անհրաժեշտ մասերը, և ստանալ թե կոնկրետ ինչ դասի է պատկանում արժեքը, որը մենք ստուգում ենք։ Ես կօգտագործեմ _slice()_ մեթոդը։ Եվ այսպիսով ֆունկցիայի վերջնական տեսքը կլինի՝

```
function toRawType (value) {
  const _toString = Object.prototype.toString;
  const str = _toString.call(value)
  return str.slice(8, -1)
}
```

Կարող ենք ևս մի քիչ կրճատել կոդի ծավալը՝ օգտագործելով _arrow function_: Կարծում եմ այն շարունակում է մնալ նույնքան հասկանալի, որքան վերևի օրինակը։

```
const toRawType = value => Object.prototype.toString.call(value).slice(8, -1);
```

Իսկ հիմա փորձենք աշխատացնել ֆունկցիան․

```
toRawType([1,2,3]); // "Array"
toRawType({color: "red"}) // "Object"
toRawType(123) // "Number"
```
