# Խնդիր համար 1 - Պալինդրոմ (Palindrome):

(Ի դեպ պարզվում է հայերեն պալինդրոմը թարգմանել են դյուրադարձուկ և դարձգիր, բայց քանի որ պալինդրոմ բառը նույնպես կիրառվում է, ձեռնպահ կմնամ անբարեհունչ համարժեքներն օգտագործելուց)․ **_Պալինդրոմը_** բառակապակցություն, նախադասություն, բառ, թիվ կամ ուղղակի սիմվոլների հաջորդականություն է, որը բացարձակ նույն ձև է կարդացվում ինչպես սովորական ձախից աջ, այնպես էլ հակառակ՝ աջից ձախ ուղղությամբ։ Օրինակ "Աննա", "քաղաք", "կատակ" բառերը պալինդրոմ են։

Մաթեմատիկայում պալինդրոմ են բոլոր 1 թվանշանով կազմված թվերի քառակուսիները, իսկ 676 թիվը ամենափոքր թիվն է, որը ոչ պալինդրոմ թվի քառակուսի է _(26-ի քառակուսին է)_։ Խնդիրը հետևյալն է․ տրված է բառ, պահանջվում է գրել ֆունկցիա, որը կվերադարձնի _true_, եթե բառը պալինդրոմ է, իսկ հակառակ դեպքում՝ _false_: Ֆունկցիան պետք է հաշվի առնի նաև բացատներն ու կետադրական նշանները։ Կա լուծման այսպիսի տարբերակ՝

```
function palindrome(str) {
  str = str.toLowerCase();
  return str === str.split('').reverse().join('');
}
```

Բառը, որի պալինդրոմ լինելը ուզում ենք ստուգել, որպես արգումենտ տալիս ենք ֆունկցիային։ Ֆունկցիայի մեջ տվյալ բառի բոլոր տառերը փոխակերպվում են փոքրատառերի, հակառակ դեպքում օրինակ հատուկ անունները ստուգելուց մենք կստանանք _false_ ( "Աննա" !== "աննԱ" ): Դրա համար օգտագործում ենք ներդրված _toLowerCase_ մեթոդը։ Հաջորդ քայլին մենք օգտագործում ենք split մեթոդը,որին որպես արգումենտ տալիս ենք դատարկ սթրինգ(''), այն մեզ թույլ է տալիս ստանալ սիմվոլների զանգված, օրինակ "աննա"- ի դեպքում այլ կլինի ["ա", "ն", "ն", "ա"]:

Քանի որ _split_ մեթոդը վերադարձնում է զանգված, միանգամից շղթայաձև, նրա վերադարձրած զանգվածի վրա կանչում ենք զանգվածների _reverse()_ մեթոդը, որը անունից էլ արդեն պարզ է որ զանգվածի էլեմենտները շուռ է տալիս հակառակ դասավորությամբ, և առաջին էլեմենտը դառնում է վերջինը, երկրորդը՝ նախավերջինը և այդպես շարունակ։ Ինչպես արդեն ասվեց _reverse()_ մեթոդը թեև հակառակ հերթականությամբ, սակայն նույնպես զանգված է վերադարձնում, հետևաբար շղթայաձև կարող ենք նրա վրա կանչել զանգվածների հաջորդ մեթոդը՝ _join_-ը։

_join_ մեթոդը _split_ մեթոդի լրիվ հակառակ գործն է անում, այսինքն զանգվածի էլեմենտները միավորելով, ստանում է _string_: Այս մեթոդին նույնպես որպես արգումենտ փոխանցում ենք դատարկ _string_, դրանով մենք ուզում ենք որ սիմվոլները կիպ միանալով նորից բառ կազմեն։ Եթե սխալվենք և որպես արգումենտ տանք ոչ թե դատարկ _string_ (''), այլ օրինակ բացատ (' '),ապա եթե ["ա", "ն", "ն", "ա"]-ի օրինակի վրա նայենք, մեթոդը կվերադարձնի "ա ն ն ա" ՝ տառերի արանքում բացատներ կլինեն, իսկ դա այն չի,ինչ մենք ուզում էինք անել։

Ստացվում է որ մենք բառը վերածեցինք զանգվածի, հետո փոխեցինք էլեմենտների դասավորությունը հակառակ հերթականությամբ, հետո այդ նոր զանգվածը նորից վերածեցինք բառի։ Այսպիսով մենք ունենք տրված բառը և նրա սիմվոլների հակառակ հերթականությամբ նոր ստացված բառը։ Քանի որ համեմատության օպերատորները վերադարձնում էն բուլյան արժեք, ապա _return_ հրահանգից հետո գրված արտահայտությունը, որը հենց համեմատություն է հանդիսանում, կվերադարձնի _true_, եթե բառը պալինդրոմ է, իսկ հակառակ դեպքում _false_:

Իրականում սա լուծման տարբերակներից միայն մեկն է, օրինակ բառի սիմվոլների հակառակ դասավորությունը ստանալու համար կարելի է օգտագործել ցիկլ կամ ռեկուրսիա, կարելի է այնպես անել,որ ֆունկցիան որպես արգումենտ բացի տողից, ընդունի նաև թիվ, կամ ասենք հաշվի չառնի բացատների առկայությունը և այլն։
