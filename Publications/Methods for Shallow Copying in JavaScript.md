# Օբյեկտների մակերեսային պատճենման (shallow copy) ի՞նչ եղանակներ կան: Ո՞ր եղանակն է ապահովում անթերի մակերեսային պատճենում: Նաև շատ էլեգանտ տարբերակ՝ spread օպերատորի օգնությամբ:

Օգտագործելով վերագրման օպերատորը՝ մենք չենք կարող ստեղծել օբյեկտային, կամ ինչպես հաճախ անվանում են հղումային տիպին պատկանող արժեքների (_Object, Array, Function, Map, Set_) անկախ պատճեններ, ինչպես որ պրիմիտիվ արժեքների դեպքում է։ Օրինակ՝

```
const user = {name: "Roman"};
const visitor = user;
visitor.name = "Artur";
alert (user.name); // "Artur"
```

Երբ մենք հայտարարում ենք փոփոխական և նրան որպես արժեք վերագրում ենք օբյեկտ, ապա այդ օբյեկտը փոփոխականի մեջ ուղիղ կերպով չի պահվում, ինչպես որ պրիմիտիվ տիպերի դեպքում էր։ Այն պահվում է հիշողության մեջ ինչ-որ բոլորովին ուրիշ տեղում, իսկ փոփոխականի մեջ ընդամենը պահվում է հիշողության այն բջիջների հասցեն, որտեղ օբյեկտը գտնվում է։ Այլ կերպ ասած մենք փոփոխականի մեջ պահում ենք հղումը, թե հիշողության մեջ կոնկրետ որտեղ է գտնվում այդ օբյեկտը։ Դրա համար այս տիպերը կոչվում են նաև հղումային։

Վերևի օրինակի մեջ _user_ փոփոխականի մեջ պահվում է _{name: "Roman"}_ օբյեկտի հասցեն, և _visitor_ փոփոխականին վերագրելով _user_-ի արժեքը, մենք իրականում նրա մեջ պատճենում ենք _{name: "Roman"}_ օբյեկտի հասցեն, ոչ թե հենց օբյեկտը։ Հետևաբար թե՛ _user_ և թե՛ _visitor_ փոփոխականներն այժմ հղվում են հիշողության նույն հատվածին, որտեղ գտնվում է _{name: "Roman"}_ օբյեկտը, և նրանց արժեքները իրականում բացարձակապես նույն օբյեկտն է։ Դրա մեջ կարող ենք համոզվել, կատարելով հետևյալ ստուգումը՝

```
alert(user === visitor); // true
```

Իսկ ինչպե՞ս ստեղծել տրված օբյեկտի լրիվ անկախ պատճենը։ Նախ նկատենք, որ օբյեկտների պատճենումը լինում է երկու տիպի՝ մակերեսային պատճենում (_shallow copy_) և խորը պատճենում (_deep copy_): Տարբերությունը կայանում է նրանում, որ խորը պատճենման դեպքում հաշվի է առնվում նաև այն, որ հատկության արժեքը նույնպես կարող է պատկանել օբյեկտային տիպի, և հետևաբար պետք է խորությամբ անցնելով ստեղծել նաև այդ օբյեկտային արժեքների անկախ պատճենները։

Առօրյա խնդիրների մեծամասնության դեպքում՝ օբյեկտների մակերեսային պատճենումը լիովին բավարար է, և մենք կդիտարկենք այդպիսի պատճենման մի քանի եղանակներ։

Օբյեկտների խորը պատճենման անհրաժեշտություն համեմատաբար ավելի քիչ է լինում, իսկ լինելու դեպքում հիմնականում օգտագործվում են կողմնակի **JavaScript** գրադարաններ, օրինակ _lodash_ ֆունկցիոնալ գրադարանը, որի **_\_.cloneDeep(obj)_** մեթոդը հաջողությամբ լուծում է այդ խնդիրը։ _HTML Living Standard_-ի մեջ սկսած _2022_ թվականից ավելացվել է **_structuredClone_** մեթոդը, որը թույլ է տալիս խորը պատճենում կատարել։ Մեթոդին մանրամասն կարող եք ծանոթանալ [այստեղ](https://developer.mozilla.org/en-US/docs/Web/API/structuredClone): Նաև քանի-որ մեթոդը համեմատաբար նոր է, այն սպասարկվում է ոչ բոլոր դիտարկիչների կողմից: [Այստեղ](https://caniuse.com/?search=structuredClone) կարող եք ծանոթանալ թե որ դիտարկիչների որ տարբերակներն են մեթոդը սպասարկում։

Օբյեկտների պարզագույն մակերեսային պատճենում կարելի է անել _for in_ ցիկլի օգնությամբ։ _for in_ ցիկլին նվիրված գրառմանս մեջ այդ մասին խոսվում է, կարող եք նայել [այս հղումով:](https://github.com/h0vhann1syan/Armenian-JavaScript-Community/blob/master/Iterating%20Over%20Object%20Properties%20with%20For...In.md)

Հաջորդ տարածված տարբերակը՝ _Object.assign_ մեթոդի օգտագործումն է։ Այն ունի հետևյալ գրելաձևը՝

- Object.assign(target, ...sources)

Որտեղ _target_-ը թիրախային օբյեկտն է, որի մեջ ուզում ենք ստեղծել ուրիշ օբյեկտների պատճենը, իսկ _․․․sources_-ը մեկ կամ մի քանի օբյեկտներն են, որոնց պատճենը ուզում ենք ստեղծել։ Վերևում բերված մեր օրինակը այժմ փորձենք ճիշտ պատճենում անել այս մեթոդի օգնությամբ՝

```
let user = {name: "Roman"};
let visitor = Object.assign({}, user);
console.log(user); // {name: "Roman"}
consle.log(visitor); // {name: "Roman"}
console.log(user === visitor); // false
```

Մեթոդին որպես առաջին արգումենտ տալիս ենք դատարկ օբյեկտ, որպես երկրորդ արգումենտ՝ _user_ օբյեկտը, որի պատճենը պատրաստվում ենք ստեղծել։ Մեթոդի վերադարձրած արժեքը, որը _user_ օբյեկտի մակերեսային պատճենն է, վերագրում ենք _visitor_ փոփոխականին։ Կատարելով երկու օբյեկտների նույնականության ստուգում, ստանում ենք _false_, որն ապացուցում է, որ նրանք իրարից լիովին անկախ օբյեկտներ են, և այժմ մի օբյեկտի դաշտում կատարված փոփոխությունն ամենևին չի անդրադառնում մյուս օբյեկտի վրա։

Իսկ հիմա դիտարկենք օբյեկտների մակերեսային պատճենման ամենաէլեգանտ տարբերակը՝ _spread_ օպերատորի օգնությամբ (...), որը հասանելի է սկսած **ES6** ստանդարտից։

```
let user = {name: "Roman"};
let visitor = {...user};
console.log(user); // {name: "Roman"}
console.log(visitor); // {name: "Roman"}
console.log(user === visitor); // false
```

Այս բոլոր տարբերակները՝ _for in_ ցիկլի, _Object,assign_ մեթոդի և _spread_ օպերատորի օգնությամբ, հիմնականում բավարարում են օբյեկտների պատճենման առօրյա մեզ անհրաժեշտ չափանիշներին։

Սակայն երբեմն անհրաժեշտ է լինում ստանալ օբյեկտի բացարձակ նման պատճեն, իսկ վերը նշված եղանակներով դա հնարավոր չէ, քանի-որ դրանք հաշվի չեն առնում հատկությունների ֆլագները, այսինքն արդյո՞ք կարելի է փոխել այդ հատկությունը, թե այն միայն կարդալու համար է, կամ արդյո՞ք այդ հատկությունը պետք է տեսանելի լինի ցիկլի համար, թե ոչ։ Բացի դրանից _for in_ ցիկլի օգնությամբ օբյեկտի պատճենման ժամանակ ցիկլը անտեսում է բոլոր այն հատկությունները, որոնց բանալիները պատկանում են **ES6** ստանդարտում ավելացված _Symbol տիպին_։

Ստորև դիտարկվող եղանակը կատարում է օբյեկտների լավագույն մակերեսային պատճենումը՝ հաշվի առնելով, թե՛ հատկության բանալիի _Symbol_ տիպին պատկանելիությունը, և թե՛ հատկությունների ֆլագները։ Գրելաձևը հետևյալն է՝

```
let clone = Object.defineProperties({}, Object.getOwnPropertyDescriptors(obj));
```

Իրականացնելով պատճենման այս եղանակը մեր օրինակում բերված օբյեկտի վրա, կստանանք՝

```
let user = {name: "Roman"};
let visitor = Object.defineProperties({}, Object.getOwnPropertyDescriptors(user));
console.log(user); // {name: "Roman"}
consle.log(visitor); // {name: "Roman"}
console.log(user === visitor); // false
```

Այս _4_ եղանակներն ամենաշատ կիրառվողներն են, ո՞րն ընտրել, կախված է առաջադրանքի բնույթից և անձնական նախընտրությունից:
