![The Future of JS](../images/javascript.jpg)

# Արդյո՞ք JavaScript-ի մայրամուտը մոտ է: Համացանցում պարբերաբար տարածվում են սենսացիոն նորություններ` մրցակից նոր ծրագրավորման լեզուների և տեխնոլոգիաների ի հայտ գալու մասին: ClojureScript, Elm, Dart և իհարկե հեղափոխական WebAssembly: Արդյո՞ք հիմնավոր են այդ կանխատեսումները:

**_JavaScript_**-ի ստեղծման պահից սկսած միշտ փորձել են ֆրոնթենդում նրան փոխարինել որևէ այլ լեզվով։ Ժամանակ առ ժամանակ ի հայտ են եկել տարբեր մրցակից լեզուներ կամ տեխնոլոգիաներ, որոնք հետագայում կամ ամբողջությամբ դուրս են մղվել, կամ էլ մարգինալ կիրառություն ունեն։ Որպես այլընտրանք, կիրառվել են բազմաթիվ մեթոդներ՝ սկսած բրաուզերների մեջ հավելվածների (_plug-in_) ներդրումով, մինչև մեխանիզմների մշակում, որը թույլ կտար կոդը գրել այլ լեզվով, իսկ հետո այն վերափոխել **_JavaScript_** կոդի։

Հավելվածների օգնությամբ վեբ ծրագրավորման ֆրոնթենդում լայն տարածում էր գտել **Java**-ն, **Flash**-ը և **Silverlight**-ը, որոնք հնարավորություն էին տալիս կայքերին ավելացնել վիդեոներ, ստանալ տարբեր անիմացիաներ և գրաֆիկներ։ Հետագայում **HTML5**-ի և **CSS3**-ի հայտնվելով այդ ամենն արդեն հնարավոր էր անել JavaScript-ի միջոցով։ Արդեն կար \<video\> թեգը, **CSS Animations**-ի հատկորոշումը (_սպեցիֆիկացիան_) և _HTML canvas-ը_, որոնց կիրառումը բերեց բրաուզերներում հավելվածների ներդրման գաղափարից աստիճանական հրաժարմանը։

Մյուս տարբերակը, որը կոչվում է տրանսփայլինգ, կոմպիլիացիայի կամ քոմփայլինգի տարատեսակ է, ուղղակի բարձր մակարդակի լեզվով գրված կոդը այն ոչ թէ վերածում է մեքենայական կամ բայթ կոդի, այլ մեկ այլ բարձր մակարդակի ծրագրավորման լեզվի կոդի։ Այս մոտեցումը ունի մի շարք թերություններ։ Բարձր մակարդակի լեզուները, ունենալով մի շարք նմանություններ թե սինթաքսով և թե իմաստաբանությամբ (_սեմանտիկայով_), այնուամենայնիվ տարբերվում են իրարից որոշ յուրահատկություններով, իսկ եթե լեզուները նաև տարբեր պարադիգմաներ են «դավանում» (_Օրինակ ընդգծված օբյեկտ օրիենտացված կամ ընդգծված ֆունկցիոնալ_), ապա հաճախ այդ տարբերությունն ավելի շատ է լինում, քան թե նմանությունը։ Եվ տրանսփայլինգի ժամանակ երբեմն հնարավոր չի լինում գտնել մյուս լեզվում այլընտրանքային կոնստրուկցիան։

Բացի դրանից կան նաև այլ թաքնված վտանգներ, լեզուները կարող են զարգանալ շատ արագ, իսկ այդ վերափոխման ծրագրերը (_տրանսփայլերները_) ուշ ուշ թարմացվեն, կամ ընդհանրապես չթարմացվեն։ Նախագծին տարբեր գրադարաններ միացնելը նույնպես կարող է խնդիրներ առաջացնել։ Այժմ էլ տրանսփայլերները վեբում լայնորեն օգտագործվում են (օրինակ **Babel**-ը), բայց հիմնականում ուրիշ նպատակով, այն է՝ JavaScript-ի նոր ստանդարտով գրված կոդը վերափոխել ավելի հին ստանդարտին (_օրինակ ES6-ով գրվածը՝ ES5-ի_), որպեսզի այն առանց խնդիր աշխատի հին բրաուզերների (_մասնավորապես internet explorer 9–11 տարբերակների համար _)։ Բացի դրանից, **Babel**-ն օգտագործվում է նաև **JavaScript**-ի ստատիկ տիպաբանությամբ դիալեկտ **TypeScript**-ի կոդը **JavaScript** կոդի վերափոխելու համար:

Այժմ դիտարկենք մի քանի լեզուներ, որոնք ժամանակին ստեղծվեցին JavaScript-ին փոխարինելու նպատակով, մարքեթինգային հզոր արշավներ և քարոզչություն տարվեց այդ լեզուները ֆրոնտենդում ամրապնդելու համար, տասնյակ և հարյուրավոր փորձագետներ ու փորձառու ծրագրավորողներ սկսեցին հոդվածներ տպագրել և հարցազրույցներ տալ, ապացուցելով թե իբր **JavaScript**-ի դարաշրջանն ավարտվել է, հայտնվել է **JavaScript** լեզվի քիլլերը, որը վերջ կդնի ֆրոնտենդում նրա դոմինանտությանը:

Ի դեպ նու՛յն ոճով, նու՛յն քարոզչությունը շարունակվում է նաև այժմ։ _Youtube_-ով վերջերս հարցազրույց էի նայում և էլի նույն ապոկալիպտիկ կանխատեսումները․․․ վերջապե՛ս, վերջապե՛ս հայտնվել է **JavaScript**-ի քիլլերը, (_այս անգամ նկատի ունեյին .Net պլատֆորմի համար նախատեսված Blazor UI-ֆրեյմվորքը_), և այն կարճ ժամանակում կջախջախի և վեբից դուրս կշպրտի **JavaScript**-ին։

Այդ կանխատեսումներին մեղմ ասած կարելի է վերաբերվել շատ մեծ թերահավատությամբ՝ ի վերջո **Blazor**-ը **JavaScript**-ի արդեն երկու տասնյակն անցնող հերթական քիլլերներից մեկն է, իսկ ուր են նրա նախորդները՝ վեբի պատմության աղբանոցում, կամ հազիվհազ քարշ են տալիս գոյությունը,տարիներով չթարմացվելով, այն դեպքում երբ **JS**-ը սկսած 2015 թվականից, ամեն տարի է թարմացվում և արդի ամենաարագ զարգացող ու ինովացիոն լեզուներից մեկն է։

Եվ այսպես բացի վերը նշված **Java**, **Flash** և **Silverlight** լեզուներից ու պլատֆորմերից, վեբի պատմության ընթացքում եղել են նաև այլ փորձեր ստեղծելու այլընտրանք **JavaScript**-ին։

2007 թվականին ստեղծված **Clojure** ֆունկցիոնալ լեզուն դիտարկվում էր որպես **JavaScript**-ի լուրջ մրցակից։ Նրա **ClojureScript** տարբերակը հեշտությամբ կոմպիլացվում է **JavaScript** կոդի։ **Clojure**-ը բնորոշվում է որպես հիանալի ճարտարապետությամբ, տրամաբանված և հուսալի լեզու, սակայն չնայած այդ ամեն ինչին, այն այդպես էլ լայն տարածում չգտավ, և այժմ շատ հազվադեպ է օգտագործվում վեբ ծրագրավորման մեջ։

2012 թվականին հայտնված **Elm** ֆունկցիոնալ լեզուն նույնպես համարվում էր **JavaScript**-ի ամենալուրջ մրցակիցներից մեկը։ Այն ուժեղ ազդեցություն էր կրել **Haskell**-ից և **JavaScript**-ից, յուրաքանչյուրից վերցնելով նրա ուժեղ կողմերը: Լեզուն ներկայացվեց շատ հարուստ և մանրամասն դոկումենտացիայով, որում բազմաթիվ օրինակներ կային, նաև կար օնլայն խնբագրիչ, որը թույլ էր տալիս հենց բրաուզերում բացել և փորձել գրված օրինակները։ Ամեն ինչ կազմակերպված էր շատ բարձր մակարդակով, որպեսզի այն վեբ ծրագրավորողները, որոնք կցանկանային անցնել այս լեզվին, որևէ խնդիր չունենային։ Չնայած այդ ամենին, **Elm**- ը նույնպես լայն տարածում չգտավ և հիմա նրա կիրառությունն աննշան է։

2011-ի աշնանը Google կորպորացիան ներկայացրեց **Dart** լեզուն, որը նպատակային ստեղծվել էր հենց **JavaScript**-ին փոխարինելու համար։ Լեզվի ստեղծողներից մեկը՝ **_Մարկ Միլլերը_**, ասում էր որ **JavaScript**-ը հիմքից այնպիսի թերություններ ունի, որ ինչքան էլ փորձեն ուղղել, հնարավոր չի լինի, և հենց դրա համար նրանք ձեռնամուխ են լինում նոր լեզվի ստեղծմանը, որն իդեալական կլինի վեբ ծրագրավորողների համար։ Նոր ստեղծված լեզուն կրում էր **Java**-ի, **JavaScript**-ի և **Golang**-ի ուժեղ ազդեցությունը։ **Dart**-ը չդարձավ **JavaScript**-ին մրցակից, մի քանի տարի ակտիվ թարմացվելուց հետո քիչ քիչ լեզվի հանդեպ հետաքրքրությունը կորեց և ներկայումս այն գոյատևում է բացառապես **Flutter** պլատֆորմի շնորհիվ, թե չէ վաղուց համալրած կլիներ _Google_-ի հերթական կիսատ թողած պրոյեկտների շարքը։

**CoffeeScript**-ը վերապահումներով կարելի է առանձին լեզու համարել։ Այն ավելի շատ **JS**-ի դիալեկտ է, և այսպես կոչված «քաղցրացնում» է **JavaScript**-ի սինթաքսը, օգնելով գրել ավելի կարճ կոդ և բարձրացնում է կոդի ընթեռնելիությունը։ Ներկայումս շատ քիչ է օգտագործվում, որովհետև ինչ լավ ու հարմար նորամուծություն որ լինում էր այդ լեզվում, **JavaScript**-ի հաջորդ ստանդարտն այն անմիջապես ներառում էր իր մեջ։ Օրինակ **ES6**-ում արդեն ներառված են թե՛ _class_-ները, թե՛ _template string_-ը, թե՛ ֆունկցիայի պարամետրերին սկզբնական արժեք վերագրելը և էլի մի շարք շատ օգտակար բաներ, որոնք կային **CoffeeScript**-ում և բացակայում էին **JavaScript**-ի հին ստանդարտներում։

**TypeScript**-ը համեմատած բոլոր նախորդների, հիանալի նախագիծ է, այն բավականին տարածված է, և շարունակում է ավելի բարձր տեմպերով զարգանալ ու կատարելագործվել ամրապնդվելով վեբ ծրագրավորման թե՛ ֆրոնտենդում և թե՛ բեքենդում (_Առանձնահատուկ կարևոր նշանակություն ունի Angular ֆրեյմվորքի և Node, Deno պլատֆորմերի կիրառության ժամանակ_): Սակայն նշենք, որ այն ինչպես և **CoffeScript**-ը, պետք է դիտարկել որպես **JavaScript**-ի դիալեկտ, երբեմն անվանում են նաև **JavaScript-ի նախապրոցեսոր** (_preprocessor_), ինչպիսին ասենք հանդիսանում է **Sass**-ը **CSS**-ի համար։ [**TypeScript**](https://www.typescriptlang.org/)
-ի մեջ **JavaScript**-ով գրված կոդը լրիվությամբ վավեր կոդ է։ Հենց իրենց պաշտոնական կայքում էլ գրված է, որ այն տիպավորված **JavaScript**-ն է, նախատեսված ցանկացած մասշտաբի ծրագիր գրելու համար։

Լեզուն ստեղծվել է 2012 թվականին՝ _Մայքրոսոֆթ_ կորպորացիայի կողմից, լեզվի հեղինակն է համարվում **Անդերս Հեյլզբերգը**, որը ստեղծել է նաև **Turbo Pascal**, **Delphi** և **C#** լեզուները։ Երևի Նաև դա է պատճառը, որ **TypeScript**-ը իր վրա կրել է **C#**-ի մեծ ազդեցությունը։ **TypeScript**-ը պետք է դիտարկել ոչ թե **JavaScript**-ի հետ մրցակցության մեջ, այլ ընդհակառակը, նրանք ուղղակի փոխլրացնում են միմյանց, և հատկապես շատ մեծ պրոյեկտների ժամանակ չափազանց օգտակար է **TypeScript** օգտագործելը, քանի-որ լեզվի ստատիկ տիպաբանությունն օգնում է խուսափել որոշ սխալներից, նամանավանդ եթե ծրագրավորողը ստատիկ, ուժեղ տիպաբանությամբ լեզուներով աշխատելուց հետո է սկսել **JavaScript**-ով կոդ գրել, և խորությամբ չի ընկալում թե պայմանավորված թույլ տիպաբանությամբ ինչ անուղղակի փոխակերպումներ կարող են լինել տիպերի հետ։

2013 թվականին **Mozilla** ընկերությունը ներկայացրեց **asm.js**-ը, որը **JavaScript**-ի համառոտ և օպտիմալացված տարբերակն էր։ Զուգահեռ օգտագործելով **Emscripten** տրանսփայլերը, նրանք կարողացան **C++** ով գրված կոդը աշխատեցնել **JavaScript**-ի վիրտուալ մեքենայի վրա։ Այդ էքսպերիմենտները հետագայում նպաստեցին **WebAssembly**-ի ի հայտ գալուն։ **WebAssembly**-ին իրենից ներկայացնում է կոդի կոմպակտ, բինար ձևաչափ։ Այն ծրագրավորման նոր լեզու չէ, այլ ավելի շուտ տեխնոլոգիա է, որը թույլ է տալիս **C, C++, Rust** և մի շարք այլ ստատիկ լեզուներով գրված կոդը **JavaScript**-ի ինտերֆեյսի միջոցով աշխատեցնել **JavaScript**-ի վիրտուալ մեքենայի վրա։

Հիմա արդեն **WebAssembly**-ին սպասարկվում է բոլոր ժամանակակից բրաուզերների կողմից։ **WebAssembly**-ի օգտագործումը թույլ է տալիս մեծացնել վեբ հավելվածների արագագործությունը։ Այն թույլ է տալիս բրաուզերների վրա գործարկել ծրագրեր և խաղեր, որոնք առաջ անհասանելի էին համարվում վեբի համար։ Բայց Նշենք, որ **JavaScript**-ի և **WebAssembly**-ի միջև սովորական վեբ կայքերի դեպքում արագագործության տարբերություն կամ չկա, կամ շատ չնչին է, կամ էլ երբեմն **JavaScript**-ը առաջատարի դիրքում է։ **JavaScript**-ը ներկայումս այնքան լավ է օպտիմիզացվում բրաուզերներում ներդրված ինտերպրետատորի կողմից, որ **_JIT_** կոմպիլյացիայի հետ միասին ապահովում է կատարման ֆանտաստիկ արագություն, անհասանելի սքրիփթային լեզուների ճնշող մեծամասնության համար։

**JavaScript - WebAssembly** արտադրողականության տարբերությունը զգալի է միայն այն դեպքերում, երբ ծրագիրը կատարում է մեծ քանակությամբ բարդ հաշվարկներ, այսինքն հիմնականում ծանրքաշային _(օրինակ 3D)_ խաղերում, տարբեր սիմուլացիաներում և նկարների կամ վիդեոների օնլայն խմբագրիչներում։

Իսկ սրանք այն ոլորտներն են, որոնք ավանդաբար **JavaScript**-ինը չէն էլ եղել, և հասանելի են դառել միայն վերջին տարիներին, _HTML5_-ի և _CSS3_-ի լայն տարածման, համակարգիչների հզորության և ինտերնետի արագության աճին զուգահեռ։ Բացի դրանից **WebAssembly**-ին լուրջ խնդիրներ է առաջացնում անվտանգության տեսակետից, քանի որ այն ցածր մակարդակով հասանելիություն ունի համակարգչի հիշողությանը։

Շատ կարևոր, եթե ոչ ամենակարևոր հարցերից մեկը նաև **WebAssembly**-ի օգտագործման կոմերցիոն նպատակահարմարությունն է։ Բիզնեսում կարևոր է ոչ միայն ծրագրի աշխատանքի արագությունն ու որակը, այլ նաև թե այդ ամենի համար ինչ ռեսուրսներ են ծախսվելու։ Ծրագիրը **C** կամ **C++** լեզուներով գրելու համար մի քանի անգամ ավելի շատ ջանքեր ու ժամանակ կպահանջի, քան **JavaScript**-ով, և հետևաբար նաև մի քանի անգամ կբարձրացնի ծրագրի ինքնարժեքը։ Ոչ մի պատվիրատու չի վճարի մի քանի անգամ ավել գումար, ինչ է թե վեբ կայքը մի քանի միլիվայրկյան ավելի արագ աշխատի, այն էլ եթե իրոք այդպես լինի, որովհետև սովորական վեբ կայքերի դեպքում **_JavaScript_**-ի և **_WebAssembly_**-ի արտադրողականության տարբերություն գրեթե չկա, նամանավանդ ներկայիս գերարագ ինտերնետի և հզոր համակարգիչների ու սմարթֆոնների պարագայում։

**Blazor**-ը՝ _C#_-ի և **Pyodide**-ը՝ _Python_-ի համար նույնպես ստեղծվել են **WebAssembly**-ի հիման վրա, սակայն շատ հեռու են տպավորիչ արդյունք ունենալուց ու ամենայն հավանականությամբ կզբաղեցնեն ընդամենը մի փոքրիկ սեգմենտ և անվանել այն հեղափոխական պլատֆորմեր ճիշտ չի լինի։ Այսպիսով ամփոփելով թեման կարող ենք ասել, որ **JavaScript**-ին ամբողջությամբ փոխարինելու պատրաստ ոչ մի լեզու կամ տեխնոլոգիա հորիզոնում անգամ չի էլ նշմարվում:

**WebAssembly** տեխնոլոգիան ընդամենը կլրացի **JavaScript**-ին բոլոր այն տեղերում, որտեղ պահանջվում է բարձր արտադրողականություն, և որտեղ զարգացումը կանգ էր առել մի որոշակի մակարդակի վրա, քանի որ դրանից ավել արտադրողականություն **JavaScript**-ով հնարավոր չէր ստանալ (_Օրինակ բրաուզերային խաղերը, տարբեր վիզուալիզացիաները, վիրտուալ աշխարհների սիմուլացիան, գիտական բարդ հաշվարկները, նկարների և վիդեոների օնլայն խմբագրիչները_):

Նաև որպես թեմային հավելում նշեմ, որ գոյություն ունի **AssemblyScript** կոչվող կոմպիլյատոր, որը հնարավորություն է տալիս **JavaScript**-ի դիալեկտ **TypeScript**-ի միջոցով գրել կոդ և այն քոմփայլ անել **WebAssembly** կոդի։ Այն բաց կոդով նախագիծ է, դեռևս ավելի շուտ էքսպերիմենտալ, բայց զարգանում է մեծ թափով։ **AssemblyScript**-ի զարգացումը կբերի նրան, որ **JavaScript** ծրագրավորողները հեշտությամբ կարող են իրենց պրոյեկտներում օգտագործել **WebAssembly**-ի մոդուլներ՝ առանց **C/C++** կամ **Rust** օգտագործելու
