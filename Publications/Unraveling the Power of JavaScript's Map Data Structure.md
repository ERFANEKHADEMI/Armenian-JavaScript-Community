# Map տվյալների կառուցվածքը (data structure). Փորձենք համեմատել օբյեկտների հետ. Ի՞նչ առավելություններ և ի՞նչ թերություններ ունի

**_JavaScript_**-ում կան տարբեր տվյալների կառուցվածքներ, և կախված ծրագրին ներկայացվող պահանջներից, ճիշտ կառուցվածք ընտրելը կարող է զգալիորեն արդյունավետ դարձնել ծրագրի աշխատանքն ու բարձրացնել կոդի ընթեռնելիությունը։ Այսօր կխոսենք մի շատ օգտակար տվյալների կառուցվածքի՝ **_Map_**-ի մասին։ **_Map_**-ի տարբեր ռեալիզացիաներ այսպես թե այնպես կան բոլոր հանրաճանաչ ծրագրավորման լեզուներում, թեև կարող են ուրիշ անուններով կոչվել։ **_JavaScript_**-ում **_Map_**-ը ներդրվել է _2015_ թվականին ընդունված ստանդարտով **(ES6 կամ ECMAScript 2015)**, նաև հենց այդ ստանդարտով կատարվեցին ահռելի քանակով նորամուծություններ, որոնք **_JavaScript_**-ը դարձրեցին լուրջ, հասուն ու շատ հարմարավետ լեզու։

**_Map_**-ը դա տվյալների կառուցվածք է, որը բաղկացած է բանալի-արժեք _(key - value)_ զույգից, ինչպես հասարակ օբյեկտները, սակայն որպես բանալի կարող է հանդիսանալ տվյալների ցանկացած տիպ, ի տարբերություն օբեկտների, որտեղ բանալին կարող է լինել միայն _String_ և _Symbol_ տիպի։ **_Map_**-ը ունի նմանություններ նաև Զանգվածի հետ, մասնավորապես այն նույնպես տվյալների կարգավորված հավաքածու է, և _size_ հատկության օգնությամբ մենք կարող ենք իմանալ թե քանի էլեմենտ է այն պարունակում։
**_Map_** կարող ենք ստեղծել _new Map()_ սինթաքսի օգնությամբ՝

```
const map = new Map();
```

Արդյունքում ստեղծվում է դատարկ **_Map_**: Արժեքները **_Map_**-ի մեջ ավելացնում ենք _map.set(key, value)_ մեթոդի օգնությամբ։ Առաջին արգումենտը միշտ դառնում է բանալի, երկրորդը` արժեք։ Օրինակ՝

```
map.set('firstName', 'Anakin');
map.set('lastName', 'Skywalker');
map.set('occupation', 'Jedi Knight');
```

**_Map_**-ը օգտագործում է _key => value_ սինթաքսը, իր մեջ գտնվող էլեմենտի բանալի-արժեք կապը ցույց տալու համար։ Օրինակ եթե վերևի օրինակը տպենք կոնսոլում, այն կունենա հետևյալ տեսքը։

```
{"firstName" => "Anakin",
"lastName" => "Skywalker",
"occupation" => "Jedi Knight"};
```

Օրինակում մենք որպես բանալի օգտագործեցինք սովորական տող, ինչպես որ օբյեկտներում է։ Օբյեկտները բացի _String_ տիպից, սկսած **ES6** ստանդարտից թույլ են տալիս որպես բանալի օգտագործել նաև _Symbol_ և վերջ։ Այսինքն եթե մենք օբյեկտի մեջ փորձենք օգտագործել ցանկացած ուրիշ տիպի պատկանող բանալի, ապա այն անուղղակիորեն կվերափոխվի _String_-ի։ Օրինակ բերեք փորձենք օբյեկտում որպես բանալի օգտագործել հենց օբյեկտ։

```
// ստեղծենք որևէ օբյեկտ
const objAsKey = {foo: 'bar'};

// օգտագործենք այդ օբյեկտը որպես բանալի
// ուրիշ օբյեկտի համար
const obj = {
  [objAsKey]: 'What will happen?'
};
```

եթե հիմա վերևի օրինակը տպենք կոնսոլում,կստանանք․

```
{'[object Object]': "What will happen?"};
```

Քանի որ օբյեկտի բանալին կարող է լինել միայն _String_ և _Symbol_ տիպի, ինտերպրետատորը կատարել է օբյեկտի անուղղակի վերափոխում _String_-ի և ստացել է _[object Object]_։ Ինչ է սա նշանակում։ Եթե հիմա մենք ստեղծենք ևս մի օբյեկտ, և նույնպես փորձենք ավելացնել obj-ի մեջ որպես բանալի, այն նույնպես կվերափոխվի _[object Object]_-ի, և մենք նախորդ արժեքը կկորցնենք։

```
const anotherObjAsKey = {baz: 'bar'};
obj[anotherObjAsKey] = "oops";
console.log(obj) // {'[object Object]': "oops"};
```

**_Map_**-ը լուծում է այս պրոբլեմը, նրա մեջ որպես բանալի կարող ենք օգտագործել ինչ ուզեք` օբյեկտ, զանգված, բուլյան արժեքներ, անգամ _NaN_:

```
// Ստեղծենք օբյեկտ
const objAsKey = {foo: 'bar'}

// Ստեղծենք Map
const map = new Map()

// Map-ում որպես բանալի օգտագործենք օբյեկտը
map.set(objAsKey, 'What will happen?')
```

Եթե այն հիմա տպենք կոնսոլում, ապա կտեսնենք որ մեր բանալին ոչ մի _[object Object]_- ի էլ չի վերածվել, ոչ մի վերափոխում չի կատարվել։

Բացի _map.set(key, value)_ սինթաքսից մենք կարող ենք նաև հենց **_Map_**-ի ստեղծման պահին միանգամից նրան տալ բանալի-արժեք զույգը։ Դրա համար կարող ենք օգտագործել ցանկացած օբյեկտ, որը ենթակա է իտերացիայի։ Հիմնականում դրա համար կիրառելի են երկչափ զանգվածները։ Վերևի օրինակը կարող ենք գրել նաև այսպես՝

```
const map = new Map([
  ['firstName','Anakin'],
  ['lastName','Skywalker'],
  ['occupation','Jedi Knight'],
])
```

Զանգվածի մեջ եղած զանգվածի առաջին էլեմենտը դառնում է բանալի, երկրորդը՝ տվյալ բանալու արժեքը։

Օբյեկտները իտերացիայի հիմնականում չեն ենթարկվում, թեև կան օբյեկտներ, որոնց վրա հնարավոր է ռեալիզացնել **[Symbol.iterator]** մեթոդը, և նրանց վրա արդեն կարելի է կանչել _for of_ ցիկլը։ Սակայն _Object.entries(obj)_ մեթոդը վերադարձնում է զանգվածների զանգված, ճիշտ նույն կառուցվածքով, որն անհրաժեշտ է **_Map_** ստեղծելուց կոնստրուկտորին որպես արգումենտ հաղորդելու համար։ Հետևաբար, եթե մենք ունենք օբյեկտ, որն ուզում ենք վերափոխել **_Map_**-ի, կարող ենք նախ _Object.entries(obj)_ սինթաքսը օգտագործելով ստանալ երկչափ զանգված, ապա այն որպես արգումենտ տալ _new Map()_ կոնստրուկտորին։ Օրինակ՝

```
const anakin = {
  firstName: 'Anakin',
  lastName: 'Skywalker',
  occupation: 'Jedi Knight',
};


const map = new Map(Object.entries(anakin));
```

Հակառակ գործողությունը՝ ստանալ օբյեկտ **_Map_**-ից, նույնպես շատ հեշտ է․

```
const obj = Object.fromEntries(map);
```

**_Map_**-ից զանգված կարող ենք ստանալ օգտագործելով _Array.from(map)_ սինթաքսը։ Մեր օրինակում՝

```
const arr = Array.from(map)
```

Ելքում կունենանք երկչափ զանգված՝

```
[
  ['firstName','Anakin'],
  ['lastName','Skywalker'],
  ['occupation','Jedi Knight']
]
```

Ինչպես արդեն ասվեց, **_Map_**-ում կարող ենք ունենալ ցանկացած տիպի բանալի։ Օրինակ փորձենք թվերով՝

```
map.set(1, 'Number one');
```

Ի տարբերություն օբյեկտի, որտեղ 1-ը կվերափոխվեր _String "1"-ի_, այստեղ նման բան չի կատարվում:
Բանալի կարող է հանդիսանալ նաև բուլյան տիպի արժեքները, օրինակ՝

```
map.set(true, 'A Boolean');
```

Անգամ _Number_ տիպին պատկանող հատուկ արժեք _NaN_-ը՝

```
const myMap = new Map();
myMap.set(NaN, 'not a number');
```

Տպենք կոնսոլում, և կստանանք {NaN => "not a number"}

Երբ ուզում ենք իմանալ **_Map_**-ի մեջ կա արդյոք տվյալ բանալին, կարող ենք օգտագործել _map.has(key)_ մեթոդը, որը վերադարձնում է _true_, եթե **_Map_**-ի մեջ կա բանալին, հակառակ դեպքում՝ _false_: Օրինակ՝

```
const map = new Map([
  ['animal', 'cat'],
  ['shape', 'triangle'],
  ['city', 'Prague'],
  ['country', 'Armenia'],
]);

map.has('firstName') // false
map.has('country') // true
```

Որպեսզի ստանանք արժեքներն ըստ բանալու, պետք է օգտագործենք _map.get(key)_ մեթոդը։

```
map.get("animal") // "cat"
```

**_Map_**-ի առավելություններից է հանդիսանում նաև այն, որ մենք ցանկացած պահի կարող ենք ստանալ նրա չափը՝ թե քանի էլեմենտ է պարունակում։ Դրա համար օգտագործում ենք _map.size_ հատկությունը։

```
map.size // 4
```

**_Map_**-ից որևէ էլեմենտ ջնջելու համար կարող ենք օգտագործել _delete_ մեթոդը։ Մեթոդը կվերադարձնի բուլյան արժեք, _true_\` եթե գտել և ջնջել է տրված էլեմենտը, և _false_\` եթե այդպիսի էլեմենտ չի կարողացել գտնել։

```
// Ջնջենք էլեմենտը բանալու օգնությամբ
map.delete( 'shape' ) // true
```

Եվ վերջապես մենք կարող ենք ջնջել **_Map_**-ի բոլոր էլեմենտները _clear_ մեթոդի օգնությամբ․

```
// դատարկում է Map-ը
map.clear()
```

**_Map_**-ի էլեմենտները հերթով արտածելու համար գոյություն ունի 3 ներդրված մեթոդ։ Այդ մեթոդները վերադարձնում են **MapIterator** կոչվող իտերացվող օբյեկտ։

```
const map = new Map([
  ['animal', 'cat'],
  ['shape', 'triangle'],
  ['city', 'Prague'],
  ['country', 'Armenia'],
]);
```

Առաջինը դիտարկենք _keys()_ մեթոդը, այն վերադարձնում է **_Map_**-ի բոլոր բանալիները:

```
map.keys() // {"animal", "shape", "city", "country"}
```

Հաջորդը՝ _map.values()_ մեթոդն է, վերադարձնում է բոլոր արժեքները.

```
map.values() // {"cat", "triangle", "Prague", "Armenia"}
```

Եվ վերջում՝ _map.entries()_ մեթոդը, որը վերադարձնում է բանալի-արժեք զույգերի իտերացվող օբյեկտ։ Այս տարբերակն է օգտագործում նաև _for of_ ցիկլը։

```
map.entries() // {"animal" => "cat", "shape" => "triangle", "city" => "Prague", "country" => "Armenia"}
```

**_Map_**-ն ունի նաև ներդրված _forEach_ մեթոդ, որը շատ նման է զանգվածի համանուն մեթոդին, ուղղակի հետադարձ կանչի _(callback)_ ֆունկցիային որպես պարամետր հանդիսանում են _value_-ն, _key_-ն և _map_-ը։ (_*Զանգվածի դեպքում՝ ընդունված է պարամետրերն անվանել item, index և array*_)

Ամփոփելով թեման կարող ենք նշել, որ թեև **_Map_**-ն իր կառուցվածքով նման է օբյեկտին, սակայն համեմատած ունի մի շարք առավելություններ։

- Map-ն ի տարբերություն օբյեկտի ունի ներդրված size մեթոդը, որը հնարավորություն է տալիս միանգամից ստանալ նրա չափը։
- Map-ն իտերացվող է, օբյեկտները՝ հիմնականում ոչ։
- Map-ը շատ ավելի ճկուն է, այստեղ մենք կարող ենք որպես բանալի օգտագործել ցանկացած տվյալի տիպ։
- Map-ի մեջ էլեմենտները երաշխավորված պահպանվում են ըստ ավելացման հերթականության։

Օբյեկտի մեջ թեև նույնպես հիմնականում այդպես է, բայց երաշխավորել դա չի կարելի։ Օրինակ այսպես կոչված **integer property**-ների առկայության դեպքում այդ հերթականությունը խախտվում է։

Իհարկե չի կարելի պնդել, որ **_Map_**-ը բոլոր առումներով գերազանցում է օբյեկտներին։ Իրականում օբյեկտները նույնպես շատ առավելություններ ունեն համեմատած **_Map_**-ի հետ։ Ամեն ինչ կախված է դիտարկվող խնդրի բնույթից։ Օրինակ օբյեկտները հրաշալի են աշխատում տվյալների ստանդարտ ձևաչափ հանդիսացող _JSON_-ի _JSON.parse()_ և _JSON.stringify()_ ֆունկցիաների հետ։ Բացի դրանից _օբյեկտի էլեմենտների հետ աշխատանքը շատ ավելի պարզ է՝ կետ օպերատորի գրելաձևը օգտագործելու շնորհիվ_։

Կապված արագագործության հետ՝ օբյեկտների հետ աշխատանքը հիմնականում ավելի արագ ու արդյունավետ է, որովհետև ցանցային դիտարկիչների engine-ները հիանալի օպտիմալացված են օբյեկտների և զանգվածների հետ աշխատելու համար։ Կան սիրողական թեսթերի արդյունքներ, որոնք ցույց են տալիս որ **_Map_**-ի հետ աշխատանքը անգամ ավելի արագ է, բայց դրանք այնքան էլ արժանահավատ չեմ համարում, և ավելի շուտ սպեցիֆիկ խնդիրների դեպքում է այդպես։ Ավելի լայն սպեկտրում օբյեկտները թեկուզ զուտ տեսականորեն պետք է, որ ավելի արագ աշխատեն, որովհետև բացի ցանցային դիտարկիչների engine-ների ամենաբարձր մակարդակով կազմակերպված օպտիմալացման, նրանք նաև շատ անգամ ավելի «թեթև» են։

Թեսթավորումն իրականում բավականին բարդ աշխատանք է, և հիմնարար գիտելիքներ ու փորձառություն է պահանջում։ Հիմնվելով սիրողական թեսթերի արդյունքների վրա չի կարելի պնդումներ անել։ Բայց ամեն դեպքում արագագործության այդ տարբերությունը փոքր է, և վճռորոշ դեր չի կարող խաղալ, և եթե **_Map_** օգտագործելով կարելի է ավելի ընթեռնելի, պարզ ու կարճ կոդ գրել, միանշանակ պետք է այն օգտագործել։

_Map_ տվյալների կառուցվածքին առավել մանրամասն կարելի է ծանոթանալ [այս հղումով](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)։
