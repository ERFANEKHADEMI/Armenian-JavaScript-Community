# Set տվյալների կառուցվածքը (data structure): Փորձենք համեմատել զանգվածի հետ: Ո՞ր դեպքերում այն հիանալի այլընտրանք կլինի զանգվածին:

_Map_ տվյալների կառուցվածքին նվիրված գրառմանս մեջ արդեն նշել եմ, որ տվյալների կառուցվածքի ճիշտ ընտրությունը կարող է օգնել գրելու ավելի պարզ, հասկանալի և արագ աշխատող կոդ, շատ դեպքերում ազատելով բարդ կոնստրուկցիաներ կիրառելու կամ լրացուցիչ ստուգումներ կատարելու անհաժեշտությունից։ Ինչպես և _Map_-ը՝ **_Set_**-ը նույնպես **_JavaScript_**-ում ներդրվեց 2015 թվականին ընդունված ստանդարտով **(ES6 կամ ECMAScript 2015)**։

**_Set_**-ը շատ նման է մաթեմատիկայում օգտագործվող բազմություն օբյեկտին։ Նույնպես թույլ է տալիս պահպանել ունիկալ տվյալներ՝ առանց որոշակի հերթականության, միայն թե ի տարբերություն մաթեմատիկական բազմության՝ այն պարտադիր պետք է լինի վերջավոր։ Ինչպես որ _Map_-ը շատ նմանություններ ուներ օբյեկտի հետ, և իրականում որոշ խնդիրների լուծման մեջ հանդիսանում էր այլընտրանք օբյեկտին, այնպես էլ **_Set_**-ը ավելի շատ այլընտրանք է հանդիսանում զանգվածներին, և որոշ դեպքերում զանգվածները փոխարինելով **_Set_**-ով՝ մենք կարող ենք շահել թե՛ կոդի պարզության և թե՛ արագագործության մեջ։

**_Set_** կարող ենք ստեղծել _new Set([iterable])_ կոնստրուկտորի միջոցով։ Գլխավորն այն է, որ որպես արգումենտ հաղորդենք միայն իտերացվող օբյեկտներ, օրինակ՝ զանգված։

```
const set = new Set([2, 4, 6, 8, 2, 6 ]);
console.log(set) // {2, 4, 6, 8}
```

**_Set_**-ի _մեթոդներն_ ու _հատկություններն_ են՝

- set.add(value) - **_Set_**-ի մեջ ավելացնում է տրված արժեքը։ Եթե այն արդեն պարունակվում է **_Set_**-ի մեջ, ոչ մի բան չի անում։ Վերադարձնում է նոր **_Set_**-ը։

- set.delete(value) - Ջնջում է արժեքը, վերադարձնում է _true_, եթե մեթոդի կանչի պահին արժեքը եղել է **_Set_**-ում, և հաջողությամբ ջնջվել է, և _false_, եթե կանչի պահին **_Set_**-ը նման արժեք չի պարունակել։

- set.has(value) - Վերադարձնում է _true_, եթե **_Set_**-ը պարունակում է նման արժեք, հակառակ դեպքում՝ _false_:

- set.clear() - Ամբողջությամբ «դատարկում» է **_Set_**-ը։

- set.size - Վերադարձնում է **_Set_**-ում պարունակվող էլեմենտների քանակը։

**_Set_**-ի էլեմենտները մենք կարող ենք հերթով արտածել, օգտագործելով ինչպես _for of_ ցիկլը, այնպես էլ _forEach_ մեթոդը։ Հետաքրքիրն այն է, որ _forEach_ մեթոդի պարամետրերը նույնպես 3-ն են՝ _value_, _valueAgain_, և հենց _Set_-ը։ Այսինքն ստացվում է, որ արժեքը արգումենտների մեջ հայտնվում է երկու անգամ։ Սա կարող է տարօրինակ համարվել, սակայն հատուկ այդպես է արվել **_Map_**-ի հետ հնարավորինս նույնական ինտերֆեյս ունենալու համար։

Այն նաև ունի նույն ներդրված մեթոդները՝ ինչ Map-ը։

- set.keys() - Վերադարձնում է _set_-ի բոլոր արժեքներից բաղկացած իտերացվող օբյեկտ։

- set.values() - Նույնպես արժեքներից բաղկացած իտերացվող օբյեկտ է վերադարձնում։ Մեթոդը գոյություն ունի զուտ _Map_-ի հետ համապատասխանության համար։ Իրականում վերադարձնում է լրիվ նույն բանը, ինչ որ _set.keys()_-ը կանչելու դեպքում։

- set.entries() - Վերադարձնում է իտերացվող օբյեկտ՝ բաղկացած [value, value] զույգից, գոյություն ունի զուտ _Map_-ի հետ համապատասխանություն ապահովելու համար։

Թվարկենք **_Set_**-ի բոլոր ուժեղ կողմերը՝ համեմատած զանգվածների հետ, որոնք հատկապես կարևոր են կոդի արդյունավետության բարձրացման համար․

- Էլեմենտների որոնումը։ Զանգվածի _indexOf()_ և _includes()_ մեթոդները, որոնք օգտագործում են զանգվածում տվյալ էլեմենտը գտնելու կամ պարզելու թե զանգվածը արդյոք պարունակում է նման էլեմենտ, դանդաղ են աշխատում։

- Էլեմենտի հեռացնելը։ **_Set_**-ում էլեմենտը հեռացնելու համար ընդամենը պետք է օգտագործել նրա արժեքը։ Զանգվածում տարբեր դիրքերից էլեմենտի հեռացման համար օգտագործում ենք _splice()_ և _shift մեթոդները_, որոնք ինչպես և վերը նշված indexOf()-ը և includes()-ը՝ համեմատաբար դանդաղ օպերացիաներ են։ Զանգվածների մեջ էլեմենտ հեռացնելուց նման բարձր արդյունավետությամբ աշխատում է միայն _pop_ մեթոդը։

- Էլեմենտ ավելացնելը։ Շատ անգամ ավելի արագ է **_Set_**-ում ավելացնել նոր էլեմենտ, քան թե զանգվածում՝ օգտագործելով արդեն հիշատակված _splice()_ և հատկապես _unshift()_ մեթոդները։ Զանգվածում էլեմենտ ավելացնելիս նման բարձր արդյունավետություն ցուցաբերում է միայն push մեթոդը։

- Աշխատանքը **NaN**-ի հետ։ _indexOf()_ մեթոդը չի կարող օգտագործվել ստուգելու համար թե արդյոք զանգվածում կա **NaN** արժեք։ Այնինչ Set-ի has() մեթոդի օգնությամբ դա հնարավոր է անել։

- Կրկնվող էլեմենտների բացառումը։ Զանգվածի դեպքում պետք կլիներ գրել լրացուցիչ կոդ, **_Set_**-ն արդեն իսկ այնպես է ստեղծված, որ կարող է պահպանել միայն ունիկալ արժեք։

Նշենք, որ մեթոդները, որոնք զանգվածն օգտագործում է էլեմենտների որոնման համար, հիմնականում ունեն ալգորիթմական բարդության **O(n)** արժեք (գծային են): Սա նշանակում է, որ կա ուղիղ կապ զանգվածի չափի և այդ մեթոդների աշխատանքի արագության մեջ։

Ի տարբերություն զանգվածների՝ **_Set_**-ի որոնման, էլեմենտ ավելացնելու և ջնջելու մեթոդների ալգորիթմական բարդությունը **O(1)** է, այսինքն հաստատուն է, և կապ չունի թե ինչ չափերի է **_Set_**-ը։ Թե՛ _10_ էլեմենտ, թե _10․000_ էլեմենտ ունեցող **_Set_**-ի դեպքում մեթոդներն աշխատում են հաստատուն բարդությամբ, ինչը շատ, շա՜տ մեծ առավելություն է։

Անգամ սորտավորված զանգվածների դեպքում, երբ օրինակ որոնումը կատարվում է ոչ թե գծային, այլ լոգարիթմական ժամանակում, միևնույնն է **_Set_**-ն ավելի արագ է աշխատում։
