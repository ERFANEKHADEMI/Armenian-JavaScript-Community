# Տիպերի վերափոխումը JS-ում։ Ի՞նչ հնարավորություններ և ծուղակներ ունի իր մեջ ԹՈՒՅԼ տիպաբանությունը։ Ուղղակի և անուղղակի վերափոխումներ:

**_JavaScript_**-ը չափազանց հանդուրժողական վերաբերմունք ունի տարբեր տիպերին պատկանող արժեքներով թվաբանական կամ այլ տիպի օպերացիաների կատարման հարցում։ Այն դեպքում, երբ օպերատորը կամ ֆունկցիան սպասում են որ օպերանդի կամ արգումենտի արժեքը պետք է լինի ասենք թե թվային, սակայն նա ստանում է տողային արժեք, ապա սխալ վերադարձնելու փոխարեն լեզվի ինտերպրետատորը փորձում է այն վերափոխել թվային արժեքի և շարունակել ծրագրի անխափան աշխատանքը:

Դա բխում է լեզվի որդեգրած թույլ տիպաբանության փիլիսոփայությունից, երբ կատարվում է տիպերի անուղղակի վերափոխումներ, որպեսզի ծրագիրը շարունակի աշխատել։ Այն հանդիսանում է **JavaScript**-ի ամենակարևոր առանձնահատկություններից մեկը, որը թեև թույլ է տալիս գրել կարճ, բայց ընթեռնելի կոդ, սակայն լի է նաև վտանգներով, քանի-որ անուղղակի փոխակերպումների արդյունքում մենք կարող ենք ստանալ ոչ այն, ինչ ցանկանում էինք։ Սա նաև **JavaScript**-ի ամենաքննադատվող առանձնահատկությունն է, քանի-որ շատերը չհասկանալով թե ինչ սկզբունքով են կատարվում այդ փոխակերպումները, **JavaScript**-ը համարում են տարօրինակ լեզու, որտեղ ինչ գրում ես, աշխատում է, բայց ոչ այնպես, ինչպես նախատեսել ես:

Որոշակի օբյեկտիվություն այդ քննադատությունների մեջ այնուամենայնիվ կա։ Քանի-որ թույլ տիպաբանությունը ստիպում է կոդում մեծացնել տարբեր լրացուցիչ ստուգումների քանակությունը, նաև համեմատած ուժեղ տիպաբանությամբ լեզուների՝ ահագին բարդացնում է ծրագրի թեսթավորումը։

Լավ բան է թույլ տիպաբանությունը թե ոչ՝ տեսակետները կարող են սկզբունքորեն տարբերվել, այն մի շարք առավելություններ ունի, սակայն ունի նաև ահռելի քանակությամբ թաքնված վտանգներ։ Ուղղակի պետք է ընդունել այն որպես փաստ, և փորձել օգտվել նրա ընձեռած հնարավորություններից և խուսափել ստեղծած «ստորջրյա խութերից»։

Գոյություն ունեն 3 առավել տարածված փոխակերպումներ՝ _տեքստային, թվային և տրամաբանական_:

- **_Տողային փոխակերպումները_** կարելի է անել ուղղակիորեն՝ **String(value)** ֆունկցիայի միջոցով։ Օրինակ՝

```
String(12) // թվային արժեք 12-ը կվերափոխվի տողային արժեք "12"-ի։
String(true) // Բուլյան արժեք true-ն կվերափոխվի տողային արժեք "true"-ի
```

Տողային փոխակերպումները լինում են նաև անուղղակի կերպով, երբ ֆունկցիան կամ օպերատորը սպասում են տողային արժեք, սակայն մենք տալիս ենք ուրիշ տիպի արժեք։ Օրինակ **alert(value)** ֆունկցիային եթե որպես արժեք տանք թիվ, այն կվերափոխվի տողի։ Կամ եթե տողային արժեքին գումարենք թվային արժեք՝ _"2" + 5 == "25":_ Տեսնելով, որ ձախ կողմի օպերանդը տող է, ինտերպրետատորը ենթադրում է, որ + օպերատորը մենք օգտագործում ենք ոչ թե որպես թվաբանական գումարման օպերատոր, այլ որպես տողերի համակցման (concatenation) օպերատոր, և 5 թվային արժեքը նույնպես վերածում է տողային արժեքի և կատարում տողերի համակցում:

- **_Թվային փոխակերպումները_** լինում են մաթեմատիկական ֆունկցիաների և արտահայտությունների մեջ։

Օրինակ եթե փորձենք տողերը բաժանել իրար վրա՝ _"8" / "2"_, ապա կստանանք 4, որովհետև հասկանալով որ մենք կատարում ենք թվաբանական գործողություն, ինտերպրետատորը փորձում է տողային արժեքը վերածել թվայինի: Մենք կարող ենք այլ տիպի արժեքներից ստանալ թվային արժեք ուղղակիորեն՝ **Number(value)** ֆունկցիայի միջոցով։

Կարևոր է հիշել, որ թվային վերափոխման ժամանակ դատարկ տողը վերածվում է 0-ի, եթե տողը դատարկ չէ, սկզբի և վերջի բացատները անտեսվում են, և մնացած մասից փորձ է կատարվում թիվը «կարդալ»։ Եթե հաջողությամբ չի պսակվում, արդյունքը լինում է _NaN_:

Բուլյան _true_ արժեքը վերածվում է 1-ի, _false_-ը՝ 0-ի։
_Null_-ը վերափոխվում է 0-ի, իսկ _undefined_-ը՝ _NaN_-ի։

Վերջին վերափոխումը շատ կարևոր է հիշել, որովհետև ամենահաճախն է դառնում սխալների պատճառ։

Բոլոր մաթեմատիկական օպերատորները (միակ բացառությունը + օպերատորն է) տարբեր տիպերի պատկանող արժեքները փորձում են անուղղակիորեն վերածել թվի։  
Օրինակ հետևյալ արտահայտության արժեքը կլինի՝

```
"8" * 3 - null - true // 23
```

Կատարվել են անուղղակի փոխակերպումներ,"8"-ը վերածվել է 8-ի, null-ը 0-ի և true-ն 1-ի։

- **_Ամենահասարակը տրամաբանական փոխակերպումներն են_**։
  Կատարվում են ուղղակիորեն **Boolean(value)** ֆունկցիայի օգնությամբ, ինչպես նաև անուղղակիորեն՝ օրինակ _if else, switch_ ու մի շարք այլ կոնստրուկցիաների և ցիկլերի պայմանի ստուգման բլոկում։ Փոխակերպման օրինաչափությունը հետևյալն է՝ այն արժեքները, որոնք ինտուիտիվ կերպով «դատարկ» են, վերածվում են false-ի, մնացած բոլորը՝ true են։

**falsy** արժեքները հետևյալն են՝

- 0
- -0
- 0n (BigInt)
- null
- undefined
- false
- NaN
- "" (դատարկ տող)

Եթե որոշ աղբյուրներում հանդիպեք որ _falsy_ արժեքները 6-ն են, այլ ոչ թե 8-ը, պետք չի զարմանալ, քանի-որ երբեմն -0-ն առանձին չեն նշում, համարելով որ այն նույն 0-ն է և ուղղակի **JavaScript**-ում թվի ներկայացման այսպես կոչված **double-precision** 64 բիթային համակարգի օգտագործման տարօրինակ հետևանքը, և որ գործնականում դրա գոյությունը մեծ խնդիրներ չի առաջացնում, թեև մաթեմատիկոսների տեսանկյունից դրա գոյությունն իսկ արդեն այլասերվածություն է: Իսկ **BigInt** տվյալների տիպը համեմատաբար վերջերս է ավելացել, և անկեղծ ասած առօրյա գործնական խնդիրների մեջ գրեթե չի օգտագործվում և շատերն են միտումնավոր անտեսում կամ մոռանում որ այդպիսի նոր տիպ կա լեզվի մեջ:

Բացի այս 8 արժեքից, մնացած բոլոր գոյություն ունեցող արժեքները տիպերի տրամաբանական վերափոխման ժամանակ վերածվում են _true_-ի, ի դեպ այդ թվում նաև դատարկ զանգվածները կամ օբյեկտները, ինչպես նաև տողը, որն իր մեջ պարունակում է 0 կամ բացատ ("0", " "):

Որպես տիպերի վերափոխման օրինակ, [այս հղումով](https://dorey.github.io/JavaScript-Equality-Table/) ծանոթացեք մի շատ պատկերավոր աղյուսակի հետ, որտեղ ցուցադրվում է, թե ինչպես է իրեն դրսևորում ոչ խիստ հավասարության օպերատորը **==** _a և b_ տարբեր տիպերի համար։
