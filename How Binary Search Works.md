# Բինար որոնման ալգորիթմը: Ո՞րն է բինար և գծային որոնման ալգորիթմերի տարբերությունը: JavaScript ծրագրավորման լեզվի միջոցով ստեղծենք ֆունկցիա, որն օգտագործելով ԲԻՆԱՐ ՈՐՈՆՄԱՆ ԱԼԳՈՐԻԹՄԸ՝ թվերի տեսակավորված զանգվածի մեջից կգտնի և կվերադարձնի որոնվող էլեմենտի ինդեքսը:

Պատկերացնենք թե մեզ անհրաժեշտ է անգլերեն-հայերեն բառարանի մեջ որոնել _middle_ բառի նշանակությունը։ Ի՞նչ մեթոդաբանություն կօգտագործենք այդ որոնումը հնարավորինս արագ անելու համար։ Մենք իհարկե կարող ենք բացել բառարանը և սկզբից էջ առ էջ կարդալով առաջ շարժվել, մինչև հասնենք _middle_ բառին։ Սակայն դա կլինի շատ երկար և ձանձրալի զբաղմունք, որովհետև մի քանի տասնյակ հազար բառերից բաղկացած բառարանի մեջ խելամիտ չի լինի նման մեթոդաբանությամբ որոնել անհրաժեշտ բառը։

Որոնումն ավելի արագ կատարելու համար ճիշտ կլինի բառարանը բացել ինչ-որ տեղ գրքի կեսից, չէ որ _m_ տառը այբուբենի մոտավորապես մեջտեղում է գտնվում։ Եվ արդեն մեջտեղից բացելու դեպքում եթե տեսնենք որ օրինակ _n_ տառով բառերն են, մենք հաստատ գիտենք որ այդ էջից սկսած մինչև բառարանի վերջին էջը մեզ այլևս պետք չէ ման գալ _middle_ բառը, քանի-որ n տառը հաջորդում է _m_ տառին, և հետևաբար _middle_ բառը պետք է լինի բառարանի առաջին կեսի մեջ։

Այսինքն ճիշտ մեթոդաբանություն ընտրելով՝ մենք մոտավորապես երկու անգամ կրճատեցինք այն բառերի քանակը, որն անհրաժեշտ էր ստուգել, _middle_ բառի թարգմանությունը գտնելու համար։ Մեզ ոչինչ չի խանգարում շարունակել նույն մեթոդաբանությամբ առաջ շարժվել և ամեն անգամ դեն նետելով ստուգման ենթակա բառերի կեսը, գտնել մեզ հետաքրքրող _middle_ բառը և իմանալ նրա նշանակությունը:

Վերցնենք մեկ ուրիշ օրինակ՝ թվերի տեսակավորված զանգված։ Օրինակ՝ [1, 2, 3, 5, 8, 10, 11, 12, 14, 17, 40, 80, 100, 120, 134, 170]: Ենթադրենք մենք որոնում ենք _10_ թիվը, որը գտնվում է _5_ ինդեքսում։ Եթե օգտվենք առաջին մեթոդաբանությունից, մենք պետք է զանգվածի էլէմենտները հերթով ստուգելով առաջ շարժվենք, մինչև գտնենք մեզ անհրաժեշտ _10_ թիվը։ Մենք այն կգտնենք _6_-րդ քայլից, սակայն այս դեպքում մեր բախտը մի փոքր բերել է։ Իսկ եթե մեզ անհրաժեշտ լիներ որոնել _170_ թիվը՞։ Դա վատագույն տարբերակն է, և մենք այն կգտնեյինք _16-րդ_ քայլից։ Զանգվածը բաղկացած է _16_ էլէմենտից և վատագույն դեպքում մենք որոնվող էլեմենտը գտանք _16_-րդ քայլից։ Եթե զանգվածը բաղկացած լիներ _1000_ էլէմենտից, վատագույն դեպքում մենք ստիպված ենք լինելու _1000_ էլեմենտ հատ առ հատ, հերթով ստուգել։ Այս մեթոդաբանության մեջ մենք օգտագործեցինք **_գծային որոնման ալգորիթմը_**, որը ենթադրում է հերթով հատ առ հատ ստուգել որոնման ենթակա ցուցակը, պահանջվող էլեմենտը գտնելու համար։ Այսինքն եթե ունենք _n_ քանակի էլեմենտներ, մենք ստիպված ենք լինելու վատագույն դեպքում կատարել _n_ քանակի համեմատություններ, մինչև գտնենք որոնվող էլեմենտը։ Այս ալգորիթմի բարդությունը հետևաբար կլինի **O(n)**:

Երկրորդ մեթոդաբանությունը կառուցվում է լիովին այլ՝ **_բինար որոնման ալգորիթմի_** վրա։ Եվ եթե մեզ պետք է այդ զանգվածի _5_-րդ ինդեքսում գտնվող _10_ թիվը, մենք կարող ենք ստուգել զանգվածի մոտավորապես մեջտեղում գտնվող էլեմենտը։ Կանգ կառնենք _7_-րդ ինդեքսում գտնվող _12_ թվի վրա։ Այն ավելի մեծ է, քան մեր որոնած _10_ թիվը, հետևաբար _12_-ից աջ ընկած թվերը մեզ այլևս պետք չեն, դրանք բոլորը հաստատ մեծ են _10_-ից։ Ստացվում է, որ հենց առաջին քայլից մենք թեև չգտանք այն էլեմենտը, որը փնտրում էինք, սակայն կիսով չափ կրճատեցինք որոնման ենթակա էլեմենտների քանակը։ Շարունակենք նույն տրամաբանությամբ, արդեն կիսված զանգվածի մեջ ընտրենք մոտավորապես մեջտեղում գտնվող էլեմենտը։ Կանգ առնենք _5_ թվի վրա, որը գտնվում է _3_ ինդեքսում։ Մեր որոնած _10_ թիվը ավելի մեծ է, քան _3_ ինդեքսում գտնվող _5_ թիվը, հետևաբար _3_ ինդեքսից ձախ գտնվող էլեմենտները մեզ նույնպես պետք չեն, նրանք հաստատ ավելի փոքր են որոնվող թվից։ Դեն ենք նետում արդեն նախնական զանգվածի կեսի ևս մի կեսը։ Որոնման ենթակա էլեմենտների քանակն արդեն պակասեց _3/4_-ով։

Մնացած զանգվածի մեջ կրկին վերցնենք մոտավորապես մեջտեղում գտնվող էլեմենտը, այն կլինի _10_-ը, որը գտնվում է _5_-րդ ինդեքսում, և որն էլ պահանջվում էր գտնել։ (_Քանի-որ զանգվածի էլեմենտների քանակը զույգ է, ուղիղ մեջտեղում գտնվող մի էլեմենտ չկա, և մեջտեղում գտնվող երկու էլեմենտներից ես միշտ որպես «հենման կետ» ընտրել եմ փոքր ինդեքս ունեցողը, օրինակ վերջին քայլի մեջ երբ մնում է [8, 10, 11, 12] էլեմենտներից բաղկացած զանգվածը, մեջտեղում գտնվող 10 և 11 էլեմենտների մեջից ընտրել եմ ավելի ցածր ինդեքսով 10 թիվը։_)

Բինար որոնման ալգորիթմն անհամեմատ արդյունավետ է։ Եթե գծային որոնման ալգորիթմի կիրառման պարագայում մենք _n_ թվով էլեմենտների առկայության դեպքում ստիպված ենք վատագույն տարբերակում _n_ անգամ կատարել համեմատություններ, մինչև գտնենք որոնվող էլեմենտը, ապա բինար որոնման ալգորիթմի կիրառության դեպքում մենք այդ արդյունքը կստանանք _log₂ⁿ_ քանակի համեմատություններ անելով։ Այսինքն բինար որոնման ալգորիթմի բարդությունը կազմում է **O(log₂ⁿ)**։

Մեր վերևի օրինակի թվերի տեսակավորված զանգվածը բաղկացած է _16_ էլեմենտից։ Գծային որոնման ալգորիթմ օգտագործելով մենք պահանջվող էլեմենտը կգտնենք վատագույն դեպքում _16_ քայլից։ Բինար որոնման ալգորիթմը պահանջվող էլեմենտը կգտնի _log₂¹⁶_ քայլից։ _log₂¹⁶_-ը հավասար է _4_-ի, հետևաբար նույնիսկ ամենաանբարենպատ դիրքում մենք ցանկացած էլեմենտը կգտնենք _4_ քայլից։

Հետաքրքիրն այն է, որ ինչքան զանգվածի չափերը մեծ է, այնքան այդ ալգորիթմերի արտադրողականության տարբերությունը ահռելի է դառնում։ Օրինակ եթե զանգվածը բաղկացած է _240,000_ էլեմենտից՝ տրված էլեմենտը գտնելու համար գծային որոնման դեպքում անհրաժեշտ կլինի վատագույն դեպքում կատարել _240,000_ քայլ։ Այնինչ բինար որոնման համար բավարար է ընդամենը _18_ քայլը, որովհետև _log₂²⁴⁰⁰⁰⁰_-ը մոտավորապես հավասար է _18_-ի (_17,87․․․ պետք է միշտ կլորացնենք դեպի մոտակա մեծ ամբողջ թիվը_)։ Համաձայնեք՝ տարբերությունը շշմեցուցիչ է։ Ինչպես արդեն հասկացանք՝ զանգվածը պետք է ՊԱՐՏԱԴԻՐ տեսակավորված լինի։ Հակառակ դեպքում անհնար է կիրառել բինար որոնման ալգորիթմը։

Այժմ փորձենք **JavaScript** ծրագրավորման լեզվի միջոցով ստեղծել **_բինար որոնման ալգորիթմի_** վրա հիմնված ֆունկցիա, որը որպես արգումենտ ստանալով թվերի տեսակավորված զանգված և որոնվող էլեմենտը՝ մեզ կվերադարձնի որոնվող էլեմենտի ինդեքսը։ Եթե թիվը զանգվածում չկա, թող վերադարձնի _-1_, ինչպես սովորաբար ընդունված է։

```
function binarySearch(sortedArray, key) {
    let start = 0;
    let end = sortedArray.length - 1;

    while (start <= end) {
        let middle = Math.floor((start + end) / 2);

        if (sortedArray[middle] === key) {
            return middle;
        } else if (sortedArray[middle] < key) {
            start = middle + 1;
        } else {
            end = middle - 1;
        }
    }

    return -1;
}
```

Հիմա քայլ առ քայլ նայենք, թե ինչպես է ֆունկցիան իրականացնում բինար որոնման ալգորիթմը։ Հայտարարում ենք ֆունկցիա, որն ունի երկու պարամետր՝ _sortedArray_ անունով տեսակավորված զանգվածը, որտեղ պետք է որոնումը կատարենք, և key անունով էլեմենտը, որի ինդեքսն էլ պահանջվում է գտնել _sortedArray_ զանգվածի մեջ։ Ֆունկցիայի մեջ հայտարարում ենք _2_ փոփոխականներ՝ _start_, որին տալիս ենք _0_ նախնական արժեքը, քանի որ զանգվածի էլեմենտների ինդեքսը սկսվում է _0_-ով, և _end_` որին որպես նախնական արժեք տալիս ենք զանգվածի վերջին էլեմենտի ինդեքսը՝ _sortedArray.length - 1_։

Հաջորդը ստեղծում ենք _while_ ցիկլը, իսկ որպես ցիկլի պայման նշում ենք, որ քանի դեռ _start_-ը փոքր կամ հավասար է _end_-ին, թող ցիկլն աշխատի։ Այժմ մեզ անհրաժեշտ է լինելու նոր փոփոխական, որն իր մեջ կպահի զանգվածի մոտավորապես մեջտեղում գտնվող էլեմենտի ինդեքսը։ Դրա համար հայտարարում ենք _middle_ անունով փոփոխական, և նրան որպես սկզբնական արժեք վերագրում ենք հետևյալ արտահայտությունը՝ _Math.floor((start + end) / 2)_ ։ Ինչու ենք այստեղ օգտագործում ներդրված _Math.floor_ մեթոդը՝ որպեսզի եթե զանգվածի էլեմենտների քանակը զույգ լինի, այն կլորացվի դեպի ներքև, դեպի ավելի ցածր ինդեքս, և այդ ինդեքսում գտնվող էլեմենտն ընդունվի որպես զանգվածի մեջտեղում գտնվող։

Ապա ստեղծում ենք _if_ պայմանի կոնստրուկցիան, որը ստանալով զանգվածի մեջտեղում գտնվող _sortedArray[middle] _ էլեմենտը՝ կհամեմատի այն _key_ պարամետրով ստացված արժեքի հետ և համընկնելու դեպքում կվերադարձնի _middle_-ի արժեքը, որը ինչպես հիշում ենք զանգվածի մեջտեղում գտնվող էլեմենտի ինդեքսն է։

Եթե _if_-ի պայմանը բավարարված չէ, ապա կստուգվի _else if_-ի պայմանը՝ _sortedArray[middle] < key_, և եթե այն վերադարձնի _true_, նշանակում է, որ մենք պետք է փոխենք _start_-ի արժեքը, վերագրելով նրան _middle + 1_, որովհետև զանգվածի մեջտեղից դեպի ձախ ընկած ոչ մի էլեմենտ այլևս չի կարող լինել մեր որոնած _key_ էլեմենտին հավասար, նրանց բոլորի արժեքը հաստատ փոքր է _key_-ի արժեքից։

Եթե ոչ _if_-ի, ոչ _else if_-ի պայմանները չեն բավարարվում, նշանակում է, որ մեր որոնած թիվը փոքր է զանգվածի այն էլեմենտից, որի ինդեքսը _middle_ փոփոխականի արժեքն է։ Հետևաբար այլևս անիմաստ է որոնել _key_ էլեմենտը զանգվածի _middle_ ինդեքսով էլեմենտից աջ։ Այնտեղ բոլոր թվերը հաստատ ավելի մեծ են մեր _key_-ի արժեքից։ Եվ այս դեպքում ոչինչ չի մնում անելու, քան թարմացնել _end_ փոփոխականի արժեքը, նրան վերագրելով _middle - 1_, որպեսզի որոնումը շարունակվի զանգվածի ձախ կեսի մեջ։

Այդպես կշարունակվի այնքան ժամանակ, քանի դեռ ցիկլի մարմնում գտնվող _if_-ի պայմանը չի կատարվել, այսինքն _key_ արգումենտի և զանգվածի որևէ էլեմենտի արժեքները չեն համընկնել։ Եթե որևէ համընկնում չկա, իսկ _start_-ի և _end_-ի արժեքներն ամեն իտերացիայի ժամանակ թարմացվելով արդեն չեն բավարարում ցիկլի պայմանին, ապա ցիկլը բնականաբար կընդհատվի, առանց արդյունքի, իսկ ֆունկցիայի վերջին տողում գրված _return_ հրահանգը կվերադարձնի _-1_, որն ընդունված է համարել զանգվածի մեջ որոնվող էլեմենտի բացակայության ինդիկատոր։

Մենք իհարկե հեշտությամբ կարող ենք ֆունկցիան մի փոքր ձևափոխել, որպեսզի այն որոնվող էլեմենտի ինդեքսի փոխարեն վերադարձնի Բուլյան արժեք՝ _true_՝ եթե զանգվածը պարունակում է այդ էլեմենտը, իսկ հակառակ պարագայում՝ _false_: Ցանկացողները կարող են դա ինքնուրույն անել:
