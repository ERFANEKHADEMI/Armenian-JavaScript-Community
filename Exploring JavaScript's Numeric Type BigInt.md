# Ինչ տարբերություններ կան BigInt և Number տվյալների տիպերի միջև: Number տիպի ո՞ր թերությունները ստիպեցին JavaScript ծրագրավորման լեզվում ավելացնել նոր տվյալների տիպը՝ BigInt-ը:

**_BigInt_**-ը համեմատաբար նոր թվային պրիմիտիվ տիպ է **_JavaScript_**-ում, որը թույլ է տալիս աշխատել կամայական մեծության ամբողջ թվերի հետ։ **_BigInt_**-ի շնորհիվ մենք կարող ենք անվտանգ պահպանել և մշակել ամբողջ թվային տվյալներ, որոնք դուրս են **_Number_** թվային տիպի մաքսիմալ արժեքից։

Հիշեցնեմ, որ **_Number_** թվային տիպը հիշողության մեջ պահպանվում է **64** բիթ **_IEEE-754_** ֆորմատով, որը նաև անվանում են _double precision floating point numbers_. Այդ ֆորմատը ենթադրում է որ **52** բիթ տրամադրվում է թվի պահպանման, **11** բիթ՝ ոչ ամբողջ մասի կետի դիրքի (եթե ամբողջ թիվ է, ապա այնտեղ 0 է), և **մի** բիթը տրամադրվում է նշանի պահպանման համար (_բացասական կամ դրական, այստեղից էլ առաջանում է -0-ի հետ կապված կազուսը_): Այս ֆորմատը մեծամասամբ բավարարում է առօրյա անհրաժեշտ խնդիրների մեծ մասի լուծմանը, և բավականին հարմար ֆորմատ է։

Սակայն այն ունի նաև մի շարք թերություններ։ Միջակայքը, որում կարելի է ճշգրիտ ու անվտանգ թվաբանական գործողություններ անել, սահմանափակվում է -2^53+1^-ից մինչև 2^53-1^։ Այս ֆորմատի յուրահատկությունը նաև այն է, որ առաջանում է 2 տեսակի զրո, դրական և բացասական(_0 և -0_),ինչը մաթեմատիկայի տեսանկյունից աբսուրդ է։ Եվ թեև ինտերպրետատորն այդ երկու զրոները մեծամասամբ ընդունում է որպես նույնական, այնուամենայնիվ որոշ դեպքերում կարող են անհարմարություններ առաջանալ։

**_BigInt_**-ը հնարավորություն է տալիս օգտագործել շատ մեծ ամբողջ թվեր և բարձր ճշգրտության թվաբանական գործողություններ կատարել նրանց հետ։ Որպեսզի ստեղծենք BigInt, անհրաժեշտ է ընդամենը թվային լիտերալի վերջում ավելացնել n տառը։ Օրինակ՝

```
const sameValue = 42n;
```

Կարելի է նաև կանչել **_BigInt_** ֆունկցիան և նրան որպես արգումենտ տալ ցանկացած սովորական թիվ, որը կարող է լինել ինչպես **_Number_**, այնպես էլ **_String_** տիպի։ Օրինակ՝

```
const bigintValue = BigInt(4521451);
const anotherValue = BigInt("2564879");
```

Թվաբանական գործողությունների ժամանակ **_BigInt_**-ը կարելի է օգտագործել որպես սովորական թիվ։ **_BigInt_**-ով կատարվելիք գործողությունը վերադարձնում է միայն **_BigInt_**: Միաժամանակ միևնույն հաշվարկի մեջ օգտագործել թե՛ **_BigInt_** և թե՛ **_Number_** չի թույլատրվում։ Օրինակ՝

```
console.log(2n + 3n) // 5n
console.log(2n + 3) // Uncaught TypeError
```

Եթե որևէ թվաբանական գործողության արդյունքում ակնկալվում է ոչ ամբողջ թիվ, ապա գործողության արդյունքից ոչ ամբողջ մասը դեն է նետվում։ **_BigInt_**-ը կարող է լինել միայն ամբողջ թիվ, ինչն անվանումից էլ արդեն պարզ է (_big integer_): Օրինակ՝

```
console.log(5n / 2n); // 2n
```

Քանի որ **_BigInt_**-ն առանձին տիպ է, **_Number_** կամ թվային արժեք պարունակող **_String_** տիպի հետ խիստ հավասարության ստուգման դեպքում, երբ տիպերի փոխակերպում չի կատարվում` համեմատությունը միշտ կլինի _false_: Օրինակ՝

```
console.log(25 === 25n) // false
console.log("25" === 25n) // false
```

Ոչ խիստ հավասարության ստուգման դեպքում կկատարվի տիպերի անուղղակի փոխակերպում, ինչի արդյունքում կունենանք վերևի օրինակից տարբերվող արդյունք՝

```
console.log(25 == 25n) // true
console.log("25" == 25n) // true
```

Երբ **_BigInt_** թվային արժեքը ուղղակիորեն փոխակերպվում է բուլյան տիպի, այդ փոխակերպումը ոչ մի բանով չի տարբերվում **_Number_** տիպի համապատասխան արժեքի փոխակերպումից։
Օրինակ բոլոր այս դեպքերում՝ if, while, for, &&, || , Boolean ֆունկցիա.

```
if(0n) {
  console.log("if");
} else {
  console.log("else");
} // կտպի else, քանի որ 0n-ը falsy արժեք է։

0n && 5 // 0n, առաջին falsy արժեքն է։
0n || 8n // 8n, առաջին truty արժեքն է։
```

Հիմնական օպերատորների մեծ մասը **_BigInt_**-ի հետ կարելի է կիրառել, օրինակ բինար + - / \* \*\* %։ Բիթային օպերացիաների օպերատորները նույնպես կարող են հաջողությամբ կիրառվել( | & << >> և ^ )։ Ունար մինուսը կարող է կիրառվել բացասական **_BigInt_** սահմանելու համար (_օրինակ՝ -8n_), սակայն ունար պլյուսը չի կարող օգտագործվել և օգտագործելու պարագայում կունենանք _TypeError_:

Եզրափակելով կարելի է ասել, որ առօրյա խնդիրների ճնշող մեծամասնության մեջ մենք դժվար թե առիթ ունենանք կիրառել **_BigInt_**, քանի որ **_Number_** տիպը հիանալիորեն կարողանում է լուծել **_JavaScript_** ծրագրավորողի առջև դրված խնդիրների մեծ մասը։ Բայց որոշ սպեցիֆիկ դեպքերում, երբ անհրաժեշտ է գործ ունենալ շատ մեծ ամբողջ թվերի հետ, կոդում մենք կարող եք հանդիպել **_BigInt_**-ի կիրառությանը։ Նաև պետք է հաշվի առնել, որ այն ներդրվել է ստանդարտ համեմատաբար վերջերս, և շատ բրաուզերներ կարող են այն չսպասարկել։

Ներքևի հղումներով կարող եք ծանոթանալ տվյալների այս նոր տիպի սպեցիֆիկացիային և նաև տեսնել, թե որ բրաուզերների ինչ տարբերակներ են սպասարկում այն։

[BigInt Specification](https://tc39.es/ecma262/#sec-bigint-objects)  
[BigInt Browser Support](https://caniuse.com/bigint)
