# Ինչպես որոնել տառը, բառը կամ ենթատողը տեքստի մեջ։ indexOf(), lastIndexOf() մեթոդների կիրառությունը։

Տեքստում բառի, սիմվոլի կամ ուղղակի ցանկացած ենթատողի որոնման համար օգտագործվում է մեզ քաջ հայտնի **_indexOf()_** մեթոդը, որը _~(Tilde)_ բիթային օպերատորի հետ օգտագործելու շնորհիվ կարող ենք շատ հետաքրքիր բան անել: Նախ բերեք վերհիշենք,թե ինչպես է վերոհիշյալ մեթոդը աշխատում։ Նա որպես առաջին արգումենտ ստանում է բառը, սիմվոլը կամ ենթատողը, որն ուզում ենք գտնել, իսկ որպես երկրորդ արգումենտ՝ այն դիրքը, որտեղից ուզում ենք որ որոնումը կատարվի։ Ահա նրա գրելաձևը՝

str.indexOf(searchValue, [fromIndex]), որտեղ․

- searchValue - բառը, սիմվոլը կամ ենթատողն է, որն ուզում ենք որոնել։

- fromIndex - սա ոչ պարտադիր (օպցիոնալ) երկրորդ պարամետրն է, այն նշում է դիրքը, որտեղից անհրաժեշտ է որոնումը կատարել։ Կարող է լինել ցանկացած ամբողջ թիվ։ Եթե մենք այն չենք նշում, ապա որպես սկզբնական արժեք դիտարկվում է _0_-ն, այսինքն որոնումը կատարվում է ամենասկզբից՝ _0_ ինդեքսից։ Եթե _fromIndex < 0_, ապա որոնումը կատարվում է ամբողջ տեքստում (_այնպես, ինչպես լիներ 0_), իսկ եթե այն մեծ է տողի երկարությունից՝ _fromIndex >= str.length_, ապա որոնումը կվերադարձնի _-1_, բացառությամբ այն դեպքի, երբ _searchValue_-ն հավասար է դատարկ տողի։ Վերջինի դեպքում այն ուղղակի կվերադարձնի տողի երկարությունը ՝ _str.length_։

Որոնումը կատարվում է հետևյալ կերպ, մեթոդը վերադարձնում է տրված ենթատողի ինդեքսը, եթե տեքստը այն պարունակում է, հակառակ դեպքում վերադարձնում է -1։ Օրինակ՝

```
const str = "Greater Armenia is the name given to the state of Armenia that emerged on the Armenian Highlands under the reign of King Artaxias I at the turn of the second century BC."
```

Գտնենք "Armenia" բառի դիրքը վերևի տեքստի մեջ

```
const result = str.indexOf("Armenia")
console.log(result)
```

Կոնսոլում կարտածվի _8_ թիվը, որովհետև "Armenia" բառը սկսվում է _8_-րդ ինդեքսից (_Չենք մոռանում,որ հաշվարկը սկսում ենք 0-ից_): Կարելի է նկատել, որ տեքստում _3_ անգամ է հիշատակվում _"Armenia"_ բառը, բայց մեզ վերադարձնում է առաջին իսկ հանդիպածի ինդեքսը։

Նաև, քանի որ ես երկրորդ արգումենտ չէի տվել ֆունկցիային, այն որոնումը սկսեց հենց ամենասկզբից։ Իսկ հիմա փորձենք տալ երկրորդ արգումենտ, որպեսզի որոնումը կատարվի մե՛ր ուզած դիրքից։

```
const result = str.indexOf("Armenia", 9)
console.log(result)
```

Կոնսոլում կտպի 50, քանի-որ տեքստի մեջ "Armenia" բառը առաջին անգամ հանդիպում է 50-րդ ինդեքսում, եթե որոնումը կատարվում է սկսած 9-րդ ինդեքսից։ Բացի այս մեթոդից, գոյություն ունի նաև նրա «երկվորյակ» մեթոդը՝ _lastIndexOf()_-ը։ Աշխատանքի սկզբունքը հիմնականում նույնն է, այն տարբերությամբ, որ այս մեթոդը որոնումը կատարում է տեքստի վերջից։ Նույնպես ունի 2 պարամետր, երկրորդը կրկին պարտադիր չէ։

Դիտարկենք վերը նշված մեր օրինակի վրա՝

```
const result = str.lastIndexOf("Armenia")
console.log(result)
```

Կոնսոլում կտպվի _78_, որովհետև տեքստում _"Armenia"_ բառը վերջից հաշված առաջին անգամ հանդիպում է _78_-րդ ինդեքսում։ Իսկ հիմա փորձենք մեթոդին տալ նաև երկրորդ արգումենտը․

```
const result = str.lastIndexOf("Armenia", 40)
console.log(result)
```

Այս անգամ կոնսոլում կտպվի _8_, քանի-որ _40-րդ_ ինդեքսից սկսած, տեքստի վերջից դեպի առաջ շարժվելով, այն հանդիպում է _"Armenia"_ բառին 8-րդ ինդեքսում։

Ի՞նչ առանձնահատկություն ունի մեթոդը։ Երբ մենք փորձենք մեթոդը օգտագործել _if_ կառուցվածքի պայմանի մեջ, կարող է չստանանք այն, ինչ նախատեսել էինք։ Բերեմ օրինակ վերևում գրված տեքստը օգտագործելով․

```
if (str.indexOf("Greater")) {
  alert("Համընկնում կա");
}
```

Եթե կոդը աշխատացնենք, ոչ մի _alert_ էլ չի լինի, բայց մենք պարզ տեսնում ենք, որ տեքստը պարունակում է _"Greater"_ բառը, և ուրեմն ինչու՞մ է կայանում խնդիրը։ Իսկ խնդիրը հետևյալն է՝ _indexOf()_ մեթոդը գտնում է _Greater_ բառը _0_-երորդ ինդեքսում, և հետևաբար վերադարձնում է _0_։ Իսկ _0_-ն ինչպես գիտենք _falsy_ արժեք է, հետևաբար _if_ կառուցվածքի պայմանը դառնում է սխալ, և մեր օրինակի դեպքում _alert_-ը չի կատարվում:

Իսկ այժմ հասկանանք թե ինչ լուծումներ կարող են լինել, բացի _str.indexOf("Greater") !== -1_ տարբերակից։ Կարելի է հրաժարվել _indexOf()_ մեթոդի կիրառությունից բոլոր այն դեպքերում, երբ մեզ պետք է ստանալ որոնվող բառի ոչ թե կոնկրետ դիրքը, այլ ուղղակի ճշտել այն կա տեքստում թե ոչ։ Դրա համար կարող ենք օգտագործել **_str.includes()_** մեթոդը, այն վերադարձնում է _true_, եթե գտնում է որոնվող բառը, հակառակ դեպքում` _false_, և վերևում քննարկված իրավիճակը այլևս չի լինի"։

Բայց կա մի նրբություն, **_includes()_** մեթոդը **_JavaScript_**-ում ներդրվել է միայն սկսած **ES6**-ից, և մինչ այդ այս խնդրի լուծման համար օգտագործվել են այլ մեթոդներ, որոնց մենք պետք է ծանոթ լինենք, քանի որ ծրագրավորողի աշխատանքը ենթադրում է նաև հին ծրագրերի սպասարկում ու բարելավում, և մենք հաճախ ենք հանդիպելու այլ լուծումների, քան **_include()_** մեթոդի օգտագործումն է։

Բացի դրանից մինչև հիմա էլ ահռելի քանակությամբ ծրագրեր են գրվում օգտագործելով **ES5** ստանդարտը, և ցանկալի կլինի ծանոթանալ մի շատ հետաքրքիր լուծման հետ՝ օգտագործելով բիթային օպերատոր **~-ն(tilde)**: «Ինչպես մնացորդով թվերից ստանալ ամբողջ թիվ, և ինչ մեթոդներ կան ստուգելու արդյոք թիվը ամբողջ է թե ոչ» գրառմանս մեջ ես արդեն անդրադարձել եմ ~ օպերատորին, եթե հետաքրքիր է,կարող եք ավելի մանրամասն ծանոթանալ։

Իսկ այստեղ ուղղակի հիշեցնեմ, որ ~n-ը հավասար է _-(n+1)_: Օրինակ՝

- ~1 -ը դառնում է -2 --> -(1+1)

- ~2 -ը դառնում է -3 --> -(2+1)

- ~0 -ն դառնում է -1 --> -(0+1)

Այսպիսով ~n -ը հավասարվում է _0_-ի այն և միայն այն դեպքում, երբ _n_-ը հավասար է _-1_-ի։ Հետևաբար **if(~str.indexOf("…"))** կառուցվածքում երբ ստուգվի պայմանը, այն _0_ կդառնա միայն այն դեպքում, երբ **_str.indexOf()_** մեթոդը վերադարձնի _-1_։ Մենք գիտենք որ մեթոդը _-1_ վերադարձնում է այն դեպքում, երբ չի կարողանում որևէ համընկնում գտնել։ Հիմա փորձենք այս եղանակը կիրառել մեր վերևի օրինակի վրա․

```
if(~str.indexOf("Greater")) {
  alert("Համընկնում կա");
}
```

_alert_-ը կատարվում է, համընկնում կա և ամեն ինչ հրաշալի աշխատում է։ Այս եղանակը կիրառելուց պետք է հաշվի առնել նաև այն, որ _~_ օպերատորը «աշխատում է» **32-բիթանոց թվերի** հետ, և շատ մեծ տեքստի դեպքում հնարավոր է պրոբլեմներ առաջանան։ Օրինակ **~4294967295**-ը նույնպես հավասարվում է _0_-ի, բայց գործնականում շատ քիչ դեպքերում է այդպիսի մեծ տեքստերում որոնում կատարելու անհրաժեշտություն առաջանում, իսկ դրանից փոքր թվերի դեպքում այս եղանակը հրաշալի և արդյունավետ աշխատում է։
